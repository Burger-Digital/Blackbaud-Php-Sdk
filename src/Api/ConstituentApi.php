<?php
/**
 * ConstituentApi
 * PHP version 7.2
 *
 * @category Class
 * @package  BurgerDigital\BlackbaudPhpSdk
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Constituent
 *
 * This API manages constituent information and related entities such as addresses, phones, emails, and notes.
 *
 * The version of the OpenAPI document: 1.0
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace BurgerDigital\BlackbaudPhpSdk\Api;

use BurgerDigital\BlackbaudPhpSdk\ApiException;
use BurgerDigital\BlackbaudPhpSdk\Configuration;
use BurgerDigital\BlackbaudPhpSdk\HeaderSelector;
use BurgerDigital\BlackbaudPhpSdk\ObjectSerializer;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;

/**
 * ConstituentApi Class Doc Comment
 *
 * @category Class
 * @package  BurgerDigital\BlackbaudPhpSdk
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ConstituentApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex)
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createConstituent
     *
     * Constituent (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\ConstituentAdd $constituent_add An object that represents the constituent to create. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\Model\PostResponse
     */
    public function createConstituent($constituent_add = null)
    {
        list($response) = $this->createConstituentWithHttpInfo($constituent_add);
        return $response;
    }

    /**
     * Operation createConstituentWithHttpInfo
     *
     * Constituent (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\ConstituentAdd $constituent_add An object that represents the constituent to create. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\Model\PostResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createConstituentWithHttpInfo($constituent_add = null)
    {
        $request = $this->createConstituentRequest($constituent_add);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BurgerDigital\BlackbaudPhpSdk\Model\PostResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BurgerDigital\BlackbaudPhpSdk\Model\PostResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\PostResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\Model\PostResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createConstituentAsync
     *
     * Constituent (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\ConstituentAdd $constituent_add An object that represents the constituent to create. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConstituentAsync($constituent_add = null)
    {
        return $this->createConstituentAsyncWithHttpInfo($constituent_add)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createConstituentAsyncWithHttpInfo
     *
     * Constituent (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\ConstituentAdd $constituent_add An object that represents the constituent to create. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConstituentAsyncWithHttpInfo($constituent_add = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\PostResponse';
        $request = $this->createConstituentRequest($constituent_add);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createConstituent'
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\ConstituentAdd $constituent_add An object that represents the constituent to create. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createConstituentRequest($constituent_add = null)
    {

        $resourcePath = '/constituents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($constituent_add)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($constituent_add));
            } else {
                $httpBody = $constituent_add;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createConstituentAttachment
     *
     * Constituent attachment (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\AttachmentAdd $attachment_add An object that represents the attachment to create. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\Model\PostResponse
     */
    public function createConstituentAttachment($attachment_add = null)
    {
        list($response) = $this->createConstituentAttachmentWithHttpInfo($attachment_add);
        return $response;
    }

    /**
     * Operation createConstituentAttachmentWithHttpInfo
     *
     * Constituent attachment (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\AttachmentAdd $attachment_add An object that represents the attachment to create. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\Model\PostResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createConstituentAttachmentWithHttpInfo($attachment_add = null)
    {
        $request = $this->createConstituentAttachmentRequest($attachment_add);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BurgerDigital\BlackbaudPhpSdk\Model\PostResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BurgerDigital\BlackbaudPhpSdk\Model\PostResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\PostResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\Model\PostResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createConstituentAttachmentAsync
     *
     * Constituent attachment (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\AttachmentAdd $attachment_add An object that represents the attachment to create. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConstituentAttachmentAsync($attachment_add = null)
    {
        return $this->createConstituentAttachmentAsyncWithHttpInfo($attachment_add)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createConstituentAttachmentAsyncWithHttpInfo
     *
     * Constituent attachment (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\AttachmentAdd $attachment_add An object that represents the attachment to create. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConstituentAttachmentAsyncWithHttpInfo($attachment_add = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\PostResponse';
        $request = $this->createConstituentAttachmentRequest($attachment_add);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createConstituentAttachment'
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\AttachmentAdd $attachment_add An object that represents the attachment to create. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createConstituentAttachmentRequest($attachment_add = null)
    {

        $resourcePath = '/constituents/attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($attachment_add)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($attachment_add));
            } else {
                $httpBody = $attachment_add;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createConstituentCode
     *
     * Constituent code (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\ConstituentCodeAdd $constituent_code_add An object that represents the constituent code to create. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\Model\PostResponse
     */
    public function createConstituentCode($constituent_code_add = null)
    {
        list($response) = $this->createConstituentCodeWithHttpInfo($constituent_code_add);
        return $response;
    }

    /**
     * Operation createConstituentCodeWithHttpInfo
     *
     * Constituent code (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\ConstituentCodeAdd $constituent_code_add An object that represents the constituent code to create. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\Model\PostResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createConstituentCodeWithHttpInfo($constituent_code_add = null)
    {
        $request = $this->createConstituentCodeRequest($constituent_code_add);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BurgerDigital\BlackbaudPhpSdk\Model\PostResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BurgerDigital\BlackbaudPhpSdk\Model\PostResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\PostResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\Model\PostResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createConstituentCodeAsync
     *
     * Constituent code (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\ConstituentCodeAdd $constituent_code_add An object that represents the constituent code to create. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConstituentCodeAsync($constituent_code_add = null)
    {
        return $this->createConstituentCodeAsyncWithHttpInfo($constituent_code_add)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createConstituentCodeAsyncWithHttpInfo
     *
     * Constituent code (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\ConstituentCodeAdd $constituent_code_add An object that represents the constituent code to create. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConstituentCodeAsyncWithHttpInfo($constituent_code_add = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\PostResponse';
        $request = $this->createConstituentCodeRequest($constituent_code_add);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createConstituentCode'
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\ConstituentCodeAdd $constituent_code_add An object that represents the constituent code to create. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createConstituentCodeRequest($constituent_code_add = null)
    {

        $resourcePath = '/constituentcodes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($constituent_code_add)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($constituent_code_add));
            } else {
                $httpBody = $constituent_code_add;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createConstituentCustomField
     *
     * Constituent custom field (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\CustomFieldAdd $custom_field_add An object that represents the custom field to create. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\Model\PostResponse
     */
    public function createConstituentCustomField($custom_field_add = null)
    {
        list($response) = $this->createConstituentCustomFieldWithHttpInfo($custom_field_add);
        return $response;
    }

    /**
     * Operation createConstituentCustomFieldWithHttpInfo
     *
     * Constituent custom field (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\CustomFieldAdd $custom_field_add An object that represents the custom field to create. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\Model\PostResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createConstituentCustomFieldWithHttpInfo($custom_field_add = null)
    {
        $request = $this->createConstituentCustomFieldRequest($custom_field_add);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BurgerDigital\BlackbaudPhpSdk\Model\PostResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BurgerDigital\BlackbaudPhpSdk\Model\PostResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\PostResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\Model\PostResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createConstituentCustomFieldAsync
     *
     * Constituent custom field (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\CustomFieldAdd $custom_field_add An object that represents the custom field to create. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConstituentCustomFieldAsync($custom_field_add = null)
    {
        return $this->createConstituentCustomFieldAsyncWithHttpInfo($custom_field_add)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createConstituentCustomFieldAsyncWithHttpInfo
     *
     * Constituent custom field (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\CustomFieldAdd $custom_field_add An object that represents the custom field to create. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConstituentCustomFieldAsyncWithHttpInfo($custom_field_add = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\PostResponse';
        $request = $this->createConstituentCustomFieldRequest($custom_field_add);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createConstituentCustomField'
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\CustomFieldAdd $custom_field_add An object that represents the custom field to create. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createConstituentCustomFieldRequest($custom_field_add = null)
    {

        $resourcePath = '/constituents/customfields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($custom_field_add)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($custom_field_add));
            } else {
                $httpBody = $custom_field_add;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createDocument
     *
     * Document (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\NewDocumentInfo $new_document_info An object that represents the document to upload. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\Model\FileDefinition
     */
    public function createDocument($new_document_info = null)
    {
        list($response) = $this->createDocumentWithHttpInfo($new_document_info);
        return $response;
    }

    /**
     * Operation createDocumentWithHttpInfo
     *
     * Document (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\NewDocumentInfo $new_document_info An object that represents the document to upload. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\Model\FileDefinition, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDocumentWithHttpInfo($new_document_info = null)
    {
        $request = $this->createDocumentRequest($new_document_info);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BurgerDigital\BlackbaudPhpSdk\Model\FileDefinition' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BurgerDigital\BlackbaudPhpSdk\Model\FileDefinition', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\FileDefinition';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\Model\FileDefinition',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createDocumentAsync
     *
     * Document (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\NewDocumentInfo $new_document_info An object that represents the document to upload. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDocumentAsync($new_document_info = null)
    {
        return $this->createDocumentAsyncWithHttpInfo($new_document_info)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDocumentAsyncWithHttpInfo
     *
     * Document (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\NewDocumentInfo $new_document_info An object that represents the document to upload. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDocumentAsyncWithHttpInfo($new_document_info = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\FileDefinition';
        $request = $this->createDocumentRequest($new_document_info);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDocument'
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\NewDocumentInfo $new_document_info An object that represents the document to upload. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createDocumentRequest($new_document_info = null)
    {

        $resourcePath = '/documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($new_document_info)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($new_document_info));
            } else {
                $httpBody = $new_document_info;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteConstituentAttachment
     *
     * Constituent attachment (Delete)
     *
     * @param  string $attachment_id The immutable system record ID of the attachment to delete. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteConstituentAttachment($attachment_id)
    {
        $this->deleteConstituentAttachmentWithHttpInfo($attachment_id);
    }

    /**
     * Operation deleteConstituentAttachmentWithHttpInfo
     *
     * Constituent attachment (Delete)
     *
     * @param  string $attachment_id The immutable system record ID of the attachment to delete. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteConstituentAttachmentWithHttpInfo($attachment_id)
    {
        $request = $this->deleteConstituentAttachmentRequest($attachment_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteConstituentAttachmentAsync
     *
     * Constituent attachment (Delete)
     *
     * @param  string $attachment_id The immutable system record ID of the attachment to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteConstituentAttachmentAsync($attachment_id)
    {
        return $this->deleteConstituentAttachmentAsyncWithHttpInfo($attachment_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteConstituentAttachmentAsyncWithHttpInfo
     *
     * Constituent attachment (Delete)
     *
     * @param  string $attachment_id The immutable system record ID of the attachment to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteConstituentAttachmentAsyncWithHttpInfo($attachment_id)
    {
        $returnType = '';
        $request = $this->deleteConstituentAttachmentRequest($attachment_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteConstituentAttachment'
     *
     * @param  string $attachment_id The immutable system record ID of the attachment to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteConstituentAttachmentRequest($attachment_id)
    {
        // verify the required parameter 'attachment_id' is set
        if ($attachment_id === null || (is_array($attachment_id) && count($attachment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachment_id when calling deleteConstituentAttachment'
            );
        }

        $resourcePath = '/constituents/attachments/{attachment_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($attachment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attachment_id' . '}',
                ObjectSerializer::toPathValue($attachment_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteConstituentCode
     *
     * Constituent code (Delete)
     *
     * @param  string $constituent_code_id The immutable system record ID of the constituent code to delete. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteConstituentCode($constituent_code_id)
    {
        $this->deleteConstituentCodeWithHttpInfo($constituent_code_id);
    }

    /**
     * Operation deleteConstituentCodeWithHttpInfo
     *
     * Constituent code (Delete)
     *
     * @param  string $constituent_code_id The immutable system record ID of the constituent code to delete. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteConstituentCodeWithHttpInfo($constituent_code_id)
    {
        $request = $this->deleteConstituentCodeRequest($constituent_code_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteConstituentCodeAsync
     *
     * Constituent code (Delete)
     *
     * @param  string $constituent_code_id The immutable system record ID of the constituent code to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteConstituentCodeAsync($constituent_code_id)
    {
        return $this->deleteConstituentCodeAsyncWithHttpInfo($constituent_code_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteConstituentCodeAsyncWithHttpInfo
     *
     * Constituent code (Delete)
     *
     * @param  string $constituent_code_id The immutable system record ID of the constituent code to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteConstituentCodeAsyncWithHttpInfo($constituent_code_id)
    {
        $returnType = '';
        $request = $this->deleteConstituentCodeRequest($constituent_code_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteConstituentCode'
     *
     * @param  string $constituent_code_id The immutable system record ID of the constituent code to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteConstituentCodeRequest($constituent_code_id)
    {
        // verify the required parameter 'constituent_code_id' is set
        if ($constituent_code_id === null || (is_array($constituent_code_id) && count($constituent_code_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $constituent_code_id when calling deleteConstituentCode'
            );
        }

        $resourcePath = '/constituentcodes/{constituent_code_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($constituent_code_id !== null) {
            $resourcePath = str_replace(
                '{' . 'constituent_code_id' . '}',
                ObjectSerializer::toPathValue($constituent_code_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteConstituentCustomField
     *
     * Constituent custom field (Delete)
     *
     * @param  string $custom_field_id The immutable system record ID of the custom field to delete. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteConstituentCustomField($custom_field_id)
    {
        $this->deleteConstituentCustomFieldWithHttpInfo($custom_field_id);
    }

    /**
     * Operation deleteConstituentCustomFieldWithHttpInfo
     *
     * Constituent custom field (Delete)
     *
     * @param  string $custom_field_id The immutable system record ID of the custom field to delete. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteConstituentCustomFieldWithHttpInfo($custom_field_id)
    {
        $request = $this->deleteConstituentCustomFieldRequest($custom_field_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteConstituentCustomFieldAsync
     *
     * Constituent custom field (Delete)
     *
     * @param  string $custom_field_id The immutable system record ID of the custom field to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteConstituentCustomFieldAsync($custom_field_id)
    {
        return $this->deleteConstituentCustomFieldAsyncWithHttpInfo($custom_field_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteConstituentCustomFieldAsyncWithHttpInfo
     *
     * Constituent custom field (Delete)
     *
     * @param  string $custom_field_id The immutable system record ID of the custom field to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteConstituentCustomFieldAsyncWithHttpInfo($custom_field_id)
    {
        $returnType = '';
        $request = $this->deleteConstituentCustomFieldRequest($custom_field_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteConstituentCustomField'
     *
     * @param  string $custom_field_id The immutable system record ID of the custom field to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteConstituentCustomFieldRequest($custom_field_id)
    {
        // verify the required parameter 'custom_field_id' is set
        if ($custom_field_id === null || (is_array($custom_field_id) && count($custom_field_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custom_field_id when calling deleteConstituentCustomField'
            );
        }

        $resourcePath = '/constituents/customfields/{custom_field_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($custom_field_id !== null) {
            $resourcePath = str_replace(
                '{' . 'custom_field_id' . '}',
                ObjectSerializer::toPathValue($custom_field_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation editConstituent
     *
     * Constituent (Edit)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\ConstituentEdit $constituent_edit An object that represents the properties of the constituent to edit. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function editConstituent($constituent_id, $constituent_edit = null)
    {
        $this->editConstituentWithHttpInfo($constituent_id, $constituent_edit);
    }

    /**
     * Operation editConstituentWithHttpInfo
     *
     * Constituent (Edit)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\ConstituentEdit $constituent_edit An object that represents the properties of the constituent to edit. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function editConstituentWithHttpInfo($constituent_id, $constituent_edit = null)
    {
        $request = $this->editConstituentRequest($constituent_id, $constituent_edit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation editConstituentAsync
     *
     * Constituent (Edit)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\ConstituentEdit $constituent_edit An object that represents the properties of the constituent to edit. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editConstituentAsync($constituent_id, $constituent_edit = null)
    {
        return $this->editConstituentAsyncWithHttpInfo($constituent_id, $constituent_edit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation editConstituentAsyncWithHttpInfo
     *
     * Constituent (Edit)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\ConstituentEdit $constituent_edit An object that represents the properties of the constituent to edit. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editConstituentAsyncWithHttpInfo($constituent_id, $constituent_edit = null)
    {
        $returnType = '';
        $request = $this->editConstituentRequest($constituent_id, $constituent_edit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'editConstituent'
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\ConstituentEdit $constituent_edit An object that represents the properties of the constituent to edit. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function editConstituentRequest($constituent_id, $constituent_edit = null)
    {
        // verify the required parameter 'constituent_id' is set
        if ($constituent_id === null || (is_array($constituent_id) && count($constituent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $constituent_id when calling editConstituent'
            );
        }

        $resourcePath = '/constituents/{constituent_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($constituent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'constituent_id' . '}',
                ObjectSerializer::toPathValue($constituent_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($constituent_edit)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($constituent_edit));
            } else {
                $httpBody = $constituent_edit;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation editConstituentAttachment
     *
     * Constituent attachment (Edit)
     *
     * @param  string $attachment_id The immutable system record ID of the attachment to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\AttachmentEdit $attachment_edit An object that represents the properties of the attachment to edit. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function editConstituentAttachment($attachment_id, $attachment_edit = null)
    {
        $this->editConstituentAttachmentWithHttpInfo($attachment_id, $attachment_edit);
    }

    /**
     * Operation editConstituentAttachmentWithHttpInfo
     *
     * Constituent attachment (Edit)
     *
     * @param  string $attachment_id The immutable system record ID of the attachment to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\AttachmentEdit $attachment_edit An object that represents the properties of the attachment to edit. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function editConstituentAttachmentWithHttpInfo($attachment_id, $attachment_edit = null)
    {
        $request = $this->editConstituentAttachmentRequest($attachment_id, $attachment_edit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation editConstituentAttachmentAsync
     *
     * Constituent attachment (Edit)
     *
     * @param  string $attachment_id The immutable system record ID of the attachment to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\AttachmentEdit $attachment_edit An object that represents the properties of the attachment to edit. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editConstituentAttachmentAsync($attachment_id, $attachment_edit = null)
    {
        return $this->editConstituentAttachmentAsyncWithHttpInfo($attachment_id, $attachment_edit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation editConstituentAttachmentAsyncWithHttpInfo
     *
     * Constituent attachment (Edit)
     *
     * @param  string $attachment_id The immutable system record ID of the attachment to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\AttachmentEdit $attachment_edit An object that represents the properties of the attachment to edit. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editConstituentAttachmentAsyncWithHttpInfo($attachment_id, $attachment_edit = null)
    {
        $returnType = '';
        $request = $this->editConstituentAttachmentRequest($attachment_id, $attachment_edit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'editConstituentAttachment'
     *
     * @param  string $attachment_id The immutable system record ID of the attachment to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\AttachmentEdit $attachment_edit An object that represents the properties of the attachment to edit. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function editConstituentAttachmentRequest($attachment_id, $attachment_edit = null)
    {
        // verify the required parameter 'attachment_id' is set
        if ($attachment_id === null || (is_array($attachment_id) && count($attachment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachment_id when calling editConstituentAttachment'
            );
        }

        $resourcePath = '/constituents/attachments/{attachment_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($attachment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attachment_id' . '}',
                ObjectSerializer::toPathValue($attachment_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($attachment_edit)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($attachment_edit));
            } else {
                $httpBody = $attachment_edit;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation editConstituentCode
     *
     * Constituent code (Edit)
     *
     * @param  string $constituent_code_id The immutable system record ID of the constituent code to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\ConstituentCodeEdit $constituent_code_edit An object that represents the properties of the constituent code to edit. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function editConstituentCode($constituent_code_id, $constituent_code_edit = null)
    {
        $this->editConstituentCodeWithHttpInfo($constituent_code_id, $constituent_code_edit);
    }

    /**
     * Operation editConstituentCodeWithHttpInfo
     *
     * Constituent code (Edit)
     *
     * @param  string $constituent_code_id The immutable system record ID of the constituent code to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\ConstituentCodeEdit $constituent_code_edit An object that represents the properties of the constituent code to edit. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function editConstituentCodeWithHttpInfo($constituent_code_id, $constituent_code_edit = null)
    {
        $request = $this->editConstituentCodeRequest($constituent_code_id, $constituent_code_edit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation editConstituentCodeAsync
     *
     * Constituent code (Edit)
     *
     * @param  string $constituent_code_id The immutable system record ID of the constituent code to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\ConstituentCodeEdit $constituent_code_edit An object that represents the properties of the constituent code to edit. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editConstituentCodeAsync($constituent_code_id, $constituent_code_edit = null)
    {
        return $this->editConstituentCodeAsyncWithHttpInfo($constituent_code_id, $constituent_code_edit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation editConstituentCodeAsyncWithHttpInfo
     *
     * Constituent code (Edit)
     *
     * @param  string $constituent_code_id The immutable system record ID of the constituent code to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\ConstituentCodeEdit $constituent_code_edit An object that represents the properties of the constituent code to edit. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editConstituentCodeAsyncWithHttpInfo($constituent_code_id, $constituent_code_edit = null)
    {
        $returnType = '';
        $request = $this->editConstituentCodeRequest($constituent_code_id, $constituent_code_edit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'editConstituentCode'
     *
     * @param  string $constituent_code_id The immutable system record ID of the constituent code to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\ConstituentCodeEdit $constituent_code_edit An object that represents the properties of the constituent code to edit. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function editConstituentCodeRequest($constituent_code_id, $constituent_code_edit = null)
    {
        // verify the required parameter 'constituent_code_id' is set
        if ($constituent_code_id === null || (is_array($constituent_code_id) && count($constituent_code_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $constituent_code_id when calling editConstituentCode'
            );
        }

        $resourcePath = '/constituentcodes/{constituent_code_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($constituent_code_id !== null) {
            $resourcePath = str_replace(
                '{' . 'constituent_code_id' . '}',
                ObjectSerializer::toPathValue($constituent_code_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($constituent_code_edit)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($constituent_code_edit));
            } else {
                $httpBody = $constituent_code_edit;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation editConstituentCustomField
     *
     * Constituent custom field (Edit)
     *
     * @param  string $custom_field_id The immutable system record ID of the custom field to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\CustomFieldEdit $custom_field_edit An object that represents the properties of the custom field to edit. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function editConstituentCustomField($custom_field_id, $custom_field_edit = null)
    {
        $this->editConstituentCustomFieldWithHttpInfo($custom_field_id, $custom_field_edit);
    }

    /**
     * Operation editConstituentCustomFieldWithHttpInfo
     *
     * Constituent custom field (Edit)
     *
     * @param  string $custom_field_id The immutable system record ID of the custom field to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\CustomFieldEdit $custom_field_edit An object that represents the properties of the custom field to edit. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function editConstituentCustomFieldWithHttpInfo($custom_field_id, $custom_field_edit = null)
    {
        $request = $this->editConstituentCustomFieldRequest($custom_field_id, $custom_field_edit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation editConstituentCustomFieldAsync
     *
     * Constituent custom field (Edit)
     *
     * @param  string $custom_field_id The immutable system record ID of the custom field to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\CustomFieldEdit $custom_field_edit An object that represents the properties of the custom field to edit. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editConstituentCustomFieldAsync($custom_field_id, $custom_field_edit = null)
    {
        return $this->editConstituentCustomFieldAsyncWithHttpInfo($custom_field_id, $custom_field_edit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation editConstituentCustomFieldAsyncWithHttpInfo
     *
     * Constituent custom field (Edit)
     *
     * @param  string $custom_field_id The immutable system record ID of the custom field to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\CustomFieldEdit $custom_field_edit An object that represents the properties of the custom field to edit. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editConstituentCustomFieldAsyncWithHttpInfo($custom_field_id, $custom_field_edit = null)
    {
        $returnType = '';
        $request = $this->editConstituentCustomFieldRequest($custom_field_id, $custom_field_edit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'editConstituentCustomField'
     *
     * @param  string $custom_field_id The immutable system record ID of the custom field to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\CustomFieldEdit $custom_field_edit An object that represents the properties of the custom field to edit. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function editConstituentCustomFieldRequest($custom_field_id, $custom_field_edit = null)
    {
        // verify the required parameter 'custom_field_id' is set
        if ($custom_field_id === null || (is_array($custom_field_id) && count($custom_field_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custom_field_id when calling editConstituentCustomField'
            );
        }

        $resourcePath = '/constituents/customfields/{custom_field_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($custom_field_id !== null) {
            $resourcePath = str_replace(
                '{' . 'custom_field_id' . '}',
                ObjectSerializer::toPathValue($custom_field_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($custom_field_edit)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($custom_field_edit));
            } else {
                $httpBody = $custom_field_edit;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConstituent
     *
     * Constituent (Get)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent for whom information is to be retrieved. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\Model\ConstituentRead
     */
    public function getConstituent($constituent_id)
    {
        list($response) = $this->getConstituentWithHttpInfo($constituent_id);
        return $response;
    }

    /**
     * Operation getConstituentWithHttpInfo
     *
     * Constituent (Get)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent for whom information is to be retrieved. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\Model\ConstituentRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConstituentWithHttpInfo($constituent_id)
    {
        $request = $this->getConstituentRequest($constituent_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BurgerDigital\BlackbaudPhpSdk\Model\ConstituentRead' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BurgerDigital\BlackbaudPhpSdk\Model\ConstituentRead', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ConstituentRead';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\Model\ConstituentRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConstituentAsync
     *
     * Constituent (Get)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent for whom information is to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConstituentAsync($constituent_id)
    {
        return $this->getConstituentAsyncWithHttpInfo($constituent_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConstituentAsyncWithHttpInfo
     *
     * Constituent (Get)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent for whom information is to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConstituentAsyncWithHttpInfo($constituent_id)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ConstituentRead';
        $request = $this->getConstituentRequest($constituent_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConstituent'
     *
     * @param  string $constituent_id The immutable system record ID of the constituent for whom information is to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getConstituentRequest($constituent_id)
    {
        // verify the required parameter 'constituent_id' is set
        if ($constituent_id === null || (is_array($constituent_id) && count($constituent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $constituent_id when calling getConstituent'
            );
        }

        $resourcePath = '/constituents/{constituent_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($constituent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'constituent_id' . '}',
                ObjectSerializer::toPathValue($constituent_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConstituentCode
     *
     * Constituent code (Get)
     *
     * @param  string $constituent_code_id The immutable system record ID of the constituent code to retrieve. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\Model\ConstituentCodeRead
     */
    public function getConstituentCode($constituent_code_id)
    {
        list($response) = $this->getConstituentCodeWithHttpInfo($constituent_code_id);
        return $response;
    }

    /**
     * Operation getConstituentCodeWithHttpInfo
     *
     * Constituent code (Get)
     *
     * @param  string $constituent_code_id The immutable system record ID of the constituent code to retrieve. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\Model\ConstituentCodeRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConstituentCodeWithHttpInfo($constituent_code_id)
    {
        $request = $this->getConstituentCodeRequest($constituent_code_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BurgerDigital\BlackbaudPhpSdk\Model\ConstituentCodeRead' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BurgerDigital\BlackbaudPhpSdk\Model\ConstituentCodeRead', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ConstituentCodeRead';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\Model\ConstituentCodeRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConstituentCodeAsync
     *
     * Constituent code (Get)
     *
     * @param  string $constituent_code_id The immutable system record ID of the constituent code to retrieve. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConstituentCodeAsync($constituent_code_id)
    {
        return $this->getConstituentCodeAsyncWithHttpInfo($constituent_code_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConstituentCodeAsyncWithHttpInfo
     *
     * Constituent code (Get)
     *
     * @param  string $constituent_code_id The immutable system record ID of the constituent code to retrieve. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConstituentCodeAsyncWithHttpInfo($constituent_code_id)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ConstituentCodeRead';
        $request = $this->getConstituentCodeRequest($constituent_code_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConstituentCode'
     *
     * @param  string $constituent_code_id The immutable system record ID of the constituent code to retrieve. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getConstituentCodeRequest($constituent_code_id)
    {
        // verify the required parameter 'constituent_code_id' is set
        if ($constituent_code_id === null || (is_array($constituent_code_id) && count($constituent_code_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $constituent_code_id when calling getConstituentCode'
            );
        }

        $resourcePath = '/constituents/constituentcodes/{constituent_code_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($constituent_code_id !== null) {
            $resourcePath = str_replace(
                '{' . 'constituent_code_id' . '}',
                ObjectSerializer::toPathValue($constituent_code_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConstituentProfilePicture
     *
     * Profile picture (Get)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the current profile picture for. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\Model\ProfilePictureRead
     */
    public function getConstituentProfilePicture($constituent_id)
    {
        list($response) = $this->getConstituentProfilePictureWithHttpInfo($constituent_id);
        return $response;
    }

    /**
     * Operation getConstituentProfilePictureWithHttpInfo
     *
     * Profile picture (Get)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the current profile picture for. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\Model\ProfilePictureRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConstituentProfilePictureWithHttpInfo($constituent_id)
    {
        $request = $this->getConstituentProfilePictureRequest($constituent_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BurgerDigital\BlackbaudPhpSdk\Model\ProfilePictureRead' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BurgerDigital\BlackbaudPhpSdk\Model\ProfilePictureRead', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ProfilePictureRead';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\Model\ProfilePictureRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConstituentProfilePictureAsync
     *
     * Profile picture (Get)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the current profile picture for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConstituentProfilePictureAsync($constituent_id)
    {
        return $this->getConstituentProfilePictureAsyncWithHttpInfo($constituent_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConstituentProfilePictureAsyncWithHttpInfo
     *
     * Profile picture (Get)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the current profile picture for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConstituentProfilePictureAsyncWithHttpInfo($constituent_id)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ProfilePictureRead';
        $request = $this->getConstituentProfilePictureRequest($constituent_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConstituentProfilePicture'
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the current profile picture for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getConstituentProfilePictureRequest($constituent_id)
    {
        // verify the required parameter 'constituent_id' is set
        if ($constituent_id === null || (is_array($constituent_id) && count($constituent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $constituent_id when calling getConstituentProfilePicture'
            );
        }

        $resourcePath = '/constituents/{constituent_id}/profilepicture';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($constituent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'constituent_id' . '}',
                ObjectSerializer::toPathValue($constituent_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCurrencyConfiguration
     *
     * Currency configuration (Get)
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\Model\CurrencyConfigurationRead
     */
    public function getCurrencyConfiguration()
    {
        list($response) = $this->getCurrencyConfigurationWithHttpInfo();
        return $response;
    }

    /**
     * Operation getCurrencyConfigurationWithHttpInfo
     *
     * Currency configuration (Get)
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\Model\CurrencyConfigurationRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCurrencyConfigurationWithHttpInfo()
    {
        $request = $this->getCurrencyConfigurationRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BurgerDigital\BlackbaudPhpSdk\Model\CurrencyConfigurationRead' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BurgerDigital\BlackbaudPhpSdk\Model\CurrencyConfigurationRead', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\CurrencyConfigurationRead';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\Model\CurrencyConfigurationRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCurrencyConfigurationAsync
     *
     * Currency configuration (Get)
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrencyConfigurationAsync()
    {
        return $this->getCurrencyConfigurationAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCurrencyConfigurationAsyncWithHttpInfo
     *
     * Currency configuration (Get)
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrencyConfigurationAsyncWithHttpInfo()
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\CurrencyConfigurationRead';
        $request = $this->getCurrencyConfigurationRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCurrencyConfiguration'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCurrencyConfigurationRequest()
    {

        $resourcePath = '/currencyconfiguration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listAttachmentTags
     *
     * Attachment tags
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString
     */
    public function listAttachmentTags()
    {
        list($response) = $this->listAttachmentTagsWithHttpInfo();
        return $response;
    }

    /**
     * Operation listAttachmentTagsWithHttpInfo
     *
     * Attachment tags
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString, HTTP status code, HTTP response headers (array of strings)
     */
    public function listAttachmentTagsWithHttpInfo()
    {
        $request = $this->listAttachmentTagsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listAttachmentTagsAsync
     *
     * Attachment tags
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAttachmentTagsAsync()
    {
        return $this->listAttachmentTagsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listAttachmentTagsAsyncWithHttpInfo
     *
     * Attachment tags
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAttachmentTagsAsyncWithHttpInfo()
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString';
        $request = $this->listAttachmentTagsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listAttachmentTags'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listAttachmentTagsRequest()
    {

        $resourcePath = '/attachmenttags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listConstituentAttachmentsSingleConstituent
     *
     * Constituent attachment list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the attachments for. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionAttachmentRead
     */
    public function listConstituentAttachmentsSingleConstituent($constituent_id)
    {
        list($response) = $this->listConstituentAttachmentsSingleConstituentWithHttpInfo($constituent_id);
        return $response;
    }

    /**
     * Operation listConstituentAttachmentsSingleConstituentWithHttpInfo
     *
     * Constituent attachment list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the attachments for. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionAttachmentRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConstituentAttachmentsSingleConstituentWithHttpInfo($constituent_id)
    {
        $request = $this->listConstituentAttachmentsSingleConstituentRequest($constituent_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionAttachmentRead' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionAttachmentRead', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionAttachmentRead';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionAttachmentRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConstituentAttachmentsSingleConstituentAsync
     *
     * Constituent attachment list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the attachments for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentAttachmentsSingleConstituentAsync($constituent_id)
    {
        return $this->listConstituentAttachmentsSingleConstituentAsyncWithHttpInfo($constituent_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConstituentAttachmentsSingleConstituentAsyncWithHttpInfo
     *
     * Constituent attachment list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the attachments for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentAttachmentsSingleConstituentAsyncWithHttpInfo($constituent_id)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionAttachmentRead';
        $request = $this->listConstituentAttachmentsSingleConstituentRequest($constituent_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listConstituentAttachmentsSingleConstituent'
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the attachments for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listConstituentAttachmentsSingleConstituentRequest($constituent_id)
    {
        // verify the required parameter 'constituent_id' is set
        if ($constituent_id === null || (is_array($constituent_id) && count($constituent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $constituent_id when calling listConstituentAttachmentsSingleConstituent'
            );
        }

        $resourcePath = '/constituents/{constituent_id}/attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($constituent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'constituent_id' . '}',
                ObjectSerializer::toPathValue($constituent_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listConstituentCodeTypes
     *
     * Constituent code types
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString
     */
    public function listConstituentCodeTypes()
    {
        list($response) = $this->listConstituentCodeTypesWithHttpInfo();
        return $response;
    }

    /**
     * Operation listConstituentCodeTypesWithHttpInfo
     *
     * Constituent code types
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConstituentCodeTypesWithHttpInfo()
    {
        $request = $this->listConstituentCodeTypesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConstituentCodeTypesAsync
     *
     * Constituent code types
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentCodeTypesAsync()
    {
        return $this->listConstituentCodeTypesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConstituentCodeTypesAsyncWithHttpInfo
     *
     * Constituent code types
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentCodeTypesAsyncWithHttpInfo()
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString';
        $request = $this->listConstituentCodeTypesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listConstituentCodeTypes'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listConstituentCodeTypesRequest()
    {

        $resourcePath = '/constituentcodetypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listConstituentCodesAllConstituents
     *
     * Constituent code list (All constituents)
     *
     * @param  bool $include_inactive Set this parameter to \&quot;true\&quot; to include inactive constituent codes in the response. (optional)
     * @param  string $date_added Format - date-time (as date-time in RFC3339). Represents a filter for constituent codes created on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $last_modified Format - date-time (as date-time in RFC3339). Represents a filter for constituent codes modified on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $sort_token Represents a token filter to provide the next stable-sorted list of constituent codes. This will be provided on the next_link collection response property when last_modified or sort_token filters are specified on the request. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionConstituentCodeRead
     */
    public function listConstituentCodesAllConstituents($include_inactive = null, $date_added = null, $last_modified = null, $sort_token = null, $limit = null, $offset = null)
    {
        list($response) = $this->listConstituentCodesAllConstituentsWithHttpInfo($include_inactive, $date_added, $last_modified, $sort_token, $limit, $offset);
        return $response;
    }

    /**
     * Operation listConstituentCodesAllConstituentsWithHttpInfo
     *
     * Constituent code list (All constituents)
     *
     * @param  bool $include_inactive Set this parameter to \&quot;true\&quot; to include inactive constituent codes in the response. (optional)
     * @param  string $date_added Format - date-time (as date-time in RFC3339). Represents a filter for constituent codes created on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $last_modified Format - date-time (as date-time in RFC3339). Represents a filter for constituent codes modified on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $sort_token Represents a token filter to provide the next stable-sorted list of constituent codes. This will be provided on the next_link collection response property when last_modified or sort_token filters are specified on the request. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionConstituentCodeRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConstituentCodesAllConstituentsWithHttpInfo($include_inactive = null, $date_added = null, $last_modified = null, $sort_token = null, $limit = null, $offset = null)
    {
        $request = $this->listConstituentCodesAllConstituentsRequest($include_inactive, $date_added, $last_modified, $sort_token, $limit, $offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionConstituentCodeRead' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionConstituentCodeRead', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionConstituentCodeRead';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionConstituentCodeRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConstituentCodesAllConstituentsAsync
     *
     * Constituent code list (All constituents)
     *
     * @param  bool $include_inactive Set this parameter to \&quot;true\&quot; to include inactive constituent codes in the response. (optional)
     * @param  string $date_added Format - date-time (as date-time in RFC3339). Represents a filter for constituent codes created on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $last_modified Format - date-time (as date-time in RFC3339). Represents a filter for constituent codes modified on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $sort_token Represents a token filter to provide the next stable-sorted list of constituent codes. This will be provided on the next_link collection response property when last_modified or sort_token filters are specified on the request. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentCodesAllConstituentsAsync($include_inactive = null, $date_added = null, $last_modified = null, $sort_token = null, $limit = null, $offset = null)
    {
        return $this->listConstituentCodesAllConstituentsAsyncWithHttpInfo($include_inactive, $date_added, $last_modified, $sort_token, $limit, $offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConstituentCodesAllConstituentsAsyncWithHttpInfo
     *
     * Constituent code list (All constituents)
     *
     * @param  bool $include_inactive Set this parameter to \&quot;true\&quot; to include inactive constituent codes in the response. (optional)
     * @param  string $date_added Format - date-time (as date-time in RFC3339). Represents a filter for constituent codes created on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $last_modified Format - date-time (as date-time in RFC3339). Represents a filter for constituent codes modified on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $sort_token Represents a token filter to provide the next stable-sorted list of constituent codes. This will be provided on the next_link collection response property when last_modified or sort_token filters are specified on the request. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentCodesAllConstituentsAsyncWithHttpInfo($include_inactive = null, $date_added = null, $last_modified = null, $sort_token = null, $limit = null, $offset = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionConstituentCodeRead';
        $request = $this->listConstituentCodesAllConstituentsRequest($include_inactive, $date_added, $last_modified, $sort_token, $limit, $offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listConstituentCodesAllConstituents'
     *
     * @param  bool $include_inactive Set this parameter to \&quot;true\&quot; to include inactive constituent codes in the response. (optional)
     * @param  string $date_added Format - date-time (as date-time in RFC3339). Represents a filter for constituent codes created on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $last_modified Format - date-time (as date-time in RFC3339). Represents a filter for constituent codes modified on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $sort_token Represents a token filter to provide the next stable-sorted list of constituent codes. This will be provided on the next_link collection response property when last_modified or sort_token filters are specified on the request. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listConstituentCodesAllConstituentsRequest($include_inactive = null, $date_added = null, $last_modified = null, $sort_token = null, $limit = null, $offset = null)
    {

        $resourcePath = '/constituents/constituentcodes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($include_inactive)) {
            $include_inactive = ObjectSerializer::serializeCollection($include_inactive, '', true);
        }
        if ($include_inactive !== null) {
            $queryParams['include_inactive'] = $include_inactive;
        }
        // query params
        if (is_array($date_added)) {
            $date_added = ObjectSerializer::serializeCollection($date_added, '', true);
        }
        if ($date_added !== null) {
            $queryParams['date_added'] = $date_added;
        }
        // query params
        if (is_array($last_modified)) {
            $last_modified = ObjectSerializer::serializeCollection($last_modified, '', true);
        }
        if ($last_modified !== null) {
            $queryParams['last_modified'] = $last_modified;
        }
        // query params
        if (is_array($sort_token)) {
            $sort_token = ObjectSerializer::serializeCollection($sort_token, '', true);
        }
        if ($sort_token !== null) {
            $queryParams['sort_token'] = $sort_token;
        }
        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }
        // query params
        if (is_array($offset)) {
            $offset = ObjectSerializer::serializeCollection($offset, '', true);
        }
        if ($offset !== null) {
            $queryParams['offset'] = $offset;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listConstituentCodesSingleConstituent
     *
     * Constituent code list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the constituent codes for. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionConstituentCodeRead
     */
    public function listConstituentCodesSingleConstituent($constituent_id)
    {
        list($response) = $this->listConstituentCodesSingleConstituentWithHttpInfo($constituent_id);
        return $response;
    }

    /**
     * Operation listConstituentCodesSingleConstituentWithHttpInfo
     *
     * Constituent code list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the constituent codes for. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionConstituentCodeRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConstituentCodesSingleConstituentWithHttpInfo($constituent_id)
    {
        $request = $this->listConstituentCodesSingleConstituentRequest($constituent_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionConstituentCodeRead' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionConstituentCodeRead', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionConstituentCodeRead';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionConstituentCodeRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConstituentCodesSingleConstituentAsync
     *
     * Constituent code list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the constituent codes for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentCodesSingleConstituentAsync($constituent_id)
    {
        return $this->listConstituentCodesSingleConstituentAsyncWithHttpInfo($constituent_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConstituentCodesSingleConstituentAsyncWithHttpInfo
     *
     * Constituent code list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the constituent codes for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentCodesSingleConstituentAsyncWithHttpInfo($constituent_id)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionConstituentCodeRead';
        $request = $this->listConstituentCodesSingleConstituentRequest($constituent_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listConstituentCodesSingleConstituent'
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the constituent codes for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listConstituentCodesSingleConstituentRequest($constituent_id)
    {
        // verify the required parameter 'constituent_id' is set
        if ($constituent_id === null || (is_array($constituent_id) && count($constituent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $constituent_id when calling listConstituentCodesSingleConstituent'
            );
        }

        $resourcePath = '/constituents/{constituent_id}/constituentcodes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($constituent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'constituent_id' . '}',
                ObjectSerializer::toPathValue($constituent_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listConstituentCustomFieldCategories
     *
     * Constituent custom field categories
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString
     */
    public function listConstituentCustomFieldCategories()
    {
        list($response) = $this->listConstituentCustomFieldCategoriesWithHttpInfo();
        return $response;
    }

    /**
     * Operation listConstituentCustomFieldCategoriesWithHttpInfo
     *
     * Constituent custom field categories
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConstituentCustomFieldCategoriesWithHttpInfo()
    {
        $request = $this->listConstituentCustomFieldCategoriesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConstituentCustomFieldCategoriesAsync
     *
     * Constituent custom field categories
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentCustomFieldCategoriesAsync()
    {
        return $this->listConstituentCustomFieldCategoriesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConstituentCustomFieldCategoriesAsyncWithHttpInfo
     *
     * Constituent custom field categories
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentCustomFieldCategoriesAsyncWithHttpInfo()
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString';
        $request = $this->listConstituentCustomFieldCategoriesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listConstituentCustomFieldCategories'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listConstituentCustomFieldCategoriesRequest()
    {

        $resourcePath = '/constituents/customfields/categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listConstituentCustomFieldCategoryDetails
     *
     * Constituent custom field category details
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionCustomFieldCategoryRead
     */
    public function listConstituentCustomFieldCategoryDetails()
    {
        list($response) = $this->listConstituentCustomFieldCategoryDetailsWithHttpInfo();
        return $response;
    }

    /**
     * Operation listConstituentCustomFieldCategoryDetailsWithHttpInfo
     *
     * Constituent custom field category details
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionCustomFieldCategoryRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConstituentCustomFieldCategoryDetailsWithHttpInfo()
    {
        $request = $this->listConstituentCustomFieldCategoryDetailsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionCustomFieldCategoryRead' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionCustomFieldCategoryRead', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionCustomFieldCategoryRead';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionCustomFieldCategoryRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConstituentCustomFieldCategoryDetailsAsync
     *
     * Constituent custom field category details
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentCustomFieldCategoryDetailsAsync()
    {
        return $this->listConstituentCustomFieldCategoryDetailsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConstituentCustomFieldCategoryDetailsAsyncWithHttpInfo
     *
     * Constituent custom field category details
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentCustomFieldCategoryDetailsAsyncWithHttpInfo()
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionCustomFieldCategoryRead';
        $request = $this->listConstituentCustomFieldCategoryDetailsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listConstituentCustomFieldCategoryDetails'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listConstituentCustomFieldCategoryDetailsRequest()
    {

        $resourcePath = '/constituents/customfields/categories/details';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listConstituentCustomFieldCategoryValues
     *
     * Constituent custom field category values
     *
     * @param  string $category_name The name of the category to return values for. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString
     */
    public function listConstituentCustomFieldCategoryValues($category_name = null)
    {
        list($response) = $this->listConstituentCustomFieldCategoryValuesWithHttpInfo($category_name);
        return $response;
    }

    /**
     * Operation listConstituentCustomFieldCategoryValuesWithHttpInfo
     *
     * Constituent custom field category values
     *
     * @param  string $category_name The name of the category to return values for. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConstituentCustomFieldCategoryValuesWithHttpInfo($category_name = null)
    {
        $request = $this->listConstituentCustomFieldCategoryValuesRequest($category_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConstituentCustomFieldCategoryValuesAsync
     *
     * Constituent custom field category values
     *
     * @param  string $category_name The name of the category to return values for. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentCustomFieldCategoryValuesAsync($category_name = null)
    {
        return $this->listConstituentCustomFieldCategoryValuesAsyncWithHttpInfo($category_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConstituentCustomFieldCategoryValuesAsyncWithHttpInfo
     *
     * Constituent custom field category values
     *
     * @param  string $category_name The name of the category to return values for. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentCustomFieldCategoryValuesAsyncWithHttpInfo($category_name = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString';
        $request = $this->listConstituentCustomFieldCategoryValuesRequest($category_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listConstituentCustomFieldCategoryValues'
     *
     * @param  string $category_name The name of the category to return values for. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listConstituentCustomFieldCategoryValuesRequest($category_name = null)
    {

        $resourcePath = '/constituents/customfields/categories/values';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($category_name)) {
            $category_name = ObjectSerializer::serializeCollection($category_name, '', true);
        }
        if ($category_name !== null) {
            $queryParams['category_name'] = $category_name;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listConstituentCustomFieldsAllConstituents
     *
     * Constituent custom field list (All constituents)
     *
     * @param  string $date_added Format - date-time (as date-time in RFC3339). Represents a filter for constituent custom fields created on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $last_modified Format - date-time (as date-time in RFC3339). Represents a filter for constituent custom fields modified on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $sort_token Represents a token filter to provide the next stable-sorted list of constituent custom fields. This will be provided on the next_link collection response property when last_modified or sort_token filters are specified on the request. (optional)
     * @param  string $category Represents a filter for custom field categories. Returns any custom fields that match the specified category. For example, &lt;i&gt;category&#x3D;Interests&lt;/i&gt; returns custom fields with the &lt;i&gt;Interests&lt;/i&gt; category. (optional)
     * @param  string $value Represents a filter for custom field values. Must be used in conjunction with the &lt;code&gt;category&lt;/code&gt; filter. Returns any custom fields in the specified category that match any of the specified values. For example, &lt;i&gt;category&#x3D;Interests&amp;amp;value&#x3D;Baseball&amp;amp;value&#x3D;Tennis&lt;/i&gt; returns &lt;i&gt;Interests&lt;/i&gt; custom fields with the &lt;i&gt;Baseball&lt;/i&gt; or &lt;i&gt;Tennis&lt;/i&gt; values. Filtering by fuzzy date values must be in one of the following formats: &lt;i&gt;YYYYMMDD&lt;/i&gt;, &lt;i&gt;YYYY&lt;/i&gt;, &lt;i&gt;YYYYMM&lt;/i&gt;, or &lt;i&gt;MMDD&lt;/i&gt;.  Any four digit value that starts with 13 or higher will be considered a year.  Any four digit value that starts with 01-12 will be considered to be in &lt;i&gt;MMDD&lt;/i&gt; format. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionCustomFieldRead
     */
    public function listConstituentCustomFieldsAllConstituents($date_added = null, $last_modified = null, $sort_token = null, $category = null, $value = null, $limit = null, $offset = null)
    {
        list($response) = $this->listConstituentCustomFieldsAllConstituentsWithHttpInfo($date_added, $last_modified, $sort_token, $category, $value, $limit, $offset);
        return $response;
    }

    /**
     * Operation listConstituentCustomFieldsAllConstituentsWithHttpInfo
     *
     * Constituent custom field list (All constituents)
     *
     * @param  string $date_added Format - date-time (as date-time in RFC3339). Represents a filter for constituent custom fields created on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $last_modified Format - date-time (as date-time in RFC3339). Represents a filter for constituent custom fields modified on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $sort_token Represents a token filter to provide the next stable-sorted list of constituent custom fields. This will be provided on the next_link collection response property when last_modified or sort_token filters are specified on the request. (optional)
     * @param  string $category Represents a filter for custom field categories. Returns any custom fields that match the specified category. For example, &lt;i&gt;category&#x3D;Interests&lt;/i&gt; returns custom fields with the &lt;i&gt;Interests&lt;/i&gt; category. (optional)
     * @param  string $value Represents a filter for custom field values. Must be used in conjunction with the &lt;code&gt;category&lt;/code&gt; filter. Returns any custom fields in the specified category that match any of the specified values. For example, &lt;i&gt;category&#x3D;Interests&amp;amp;value&#x3D;Baseball&amp;amp;value&#x3D;Tennis&lt;/i&gt; returns &lt;i&gt;Interests&lt;/i&gt; custom fields with the &lt;i&gt;Baseball&lt;/i&gt; or &lt;i&gt;Tennis&lt;/i&gt; values. Filtering by fuzzy date values must be in one of the following formats: &lt;i&gt;YYYYMMDD&lt;/i&gt;, &lt;i&gt;YYYY&lt;/i&gt;, &lt;i&gt;YYYYMM&lt;/i&gt;, or &lt;i&gt;MMDD&lt;/i&gt;.  Any four digit value that starts with 13 or higher will be considered a year.  Any four digit value that starts with 01-12 will be considered to be in &lt;i&gt;MMDD&lt;/i&gt; format. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionCustomFieldRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConstituentCustomFieldsAllConstituentsWithHttpInfo($date_added = null, $last_modified = null, $sort_token = null, $category = null, $value = null, $limit = null, $offset = null)
    {
        $request = $this->listConstituentCustomFieldsAllConstituentsRequest($date_added, $last_modified, $sort_token, $category, $value, $limit, $offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionCustomFieldRead' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionCustomFieldRead', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionCustomFieldRead';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionCustomFieldRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConstituentCustomFieldsAllConstituentsAsync
     *
     * Constituent custom field list (All constituents)
     *
     * @param  string $date_added Format - date-time (as date-time in RFC3339). Represents a filter for constituent custom fields created on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $last_modified Format - date-time (as date-time in RFC3339). Represents a filter for constituent custom fields modified on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $sort_token Represents a token filter to provide the next stable-sorted list of constituent custom fields. This will be provided on the next_link collection response property when last_modified or sort_token filters are specified on the request. (optional)
     * @param  string $category Represents a filter for custom field categories. Returns any custom fields that match the specified category. For example, &lt;i&gt;category&#x3D;Interests&lt;/i&gt; returns custom fields with the &lt;i&gt;Interests&lt;/i&gt; category. (optional)
     * @param  string $value Represents a filter for custom field values. Must be used in conjunction with the &lt;code&gt;category&lt;/code&gt; filter. Returns any custom fields in the specified category that match any of the specified values. For example, &lt;i&gt;category&#x3D;Interests&amp;amp;value&#x3D;Baseball&amp;amp;value&#x3D;Tennis&lt;/i&gt; returns &lt;i&gt;Interests&lt;/i&gt; custom fields with the &lt;i&gt;Baseball&lt;/i&gt; or &lt;i&gt;Tennis&lt;/i&gt; values. Filtering by fuzzy date values must be in one of the following formats: &lt;i&gt;YYYYMMDD&lt;/i&gt;, &lt;i&gt;YYYY&lt;/i&gt;, &lt;i&gt;YYYYMM&lt;/i&gt;, or &lt;i&gt;MMDD&lt;/i&gt;.  Any four digit value that starts with 13 or higher will be considered a year.  Any four digit value that starts with 01-12 will be considered to be in &lt;i&gt;MMDD&lt;/i&gt; format. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentCustomFieldsAllConstituentsAsync($date_added = null, $last_modified = null, $sort_token = null, $category = null, $value = null, $limit = null, $offset = null)
    {
        return $this->listConstituentCustomFieldsAllConstituentsAsyncWithHttpInfo($date_added, $last_modified, $sort_token, $category, $value, $limit, $offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConstituentCustomFieldsAllConstituentsAsyncWithHttpInfo
     *
     * Constituent custom field list (All constituents)
     *
     * @param  string $date_added Format - date-time (as date-time in RFC3339). Represents a filter for constituent custom fields created on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $last_modified Format - date-time (as date-time in RFC3339). Represents a filter for constituent custom fields modified on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $sort_token Represents a token filter to provide the next stable-sorted list of constituent custom fields. This will be provided on the next_link collection response property when last_modified or sort_token filters are specified on the request. (optional)
     * @param  string $category Represents a filter for custom field categories. Returns any custom fields that match the specified category. For example, &lt;i&gt;category&#x3D;Interests&lt;/i&gt; returns custom fields with the &lt;i&gt;Interests&lt;/i&gt; category. (optional)
     * @param  string $value Represents a filter for custom field values. Must be used in conjunction with the &lt;code&gt;category&lt;/code&gt; filter. Returns any custom fields in the specified category that match any of the specified values. For example, &lt;i&gt;category&#x3D;Interests&amp;amp;value&#x3D;Baseball&amp;amp;value&#x3D;Tennis&lt;/i&gt; returns &lt;i&gt;Interests&lt;/i&gt; custom fields with the &lt;i&gt;Baseball&lt;/i&gt; or &lt;i&gt;Tennis&lt;/i&gt; values. Filtering by fuzzy date values must be in one of the following formats: &lt;i&gt;YYYYMMDD&lt;/i&gt;, &lt;i&gt;YYYY&lt;/i&gt;, &lt;i&gt;YYYYMM&lt;/i&gt;, or &lt;i&gt;MMDD&lt;/i&gt;.  Any four digit value that starts with 13 or higher will be considered a year.  Any four digit value that starts with 01-12 will be considered to be in &lt;i&gt;MMDD&lt;/i&gt; format. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentCustomFieldsAllConstituentsAsyncWithHttpInfo($date_added = null, $last_modified = null, $sort_token = null, $category = null, $value = null, $limit = null, $offset = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionCustomFieldRead';
        $request = $this->listConstituentCustomFieldsAllConstituentsRequest($date_added, $last_modified, $sort_token, $category, $value, $limit, $offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listConstituentCustomFieldsAllConstituents'
     *
     * @param  string $date_added Format - date-time (as date-time in RFC3339). Represents a filter for constituent custom fields created on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $last_modified Format - date-time (as date-time in RFC3339). Represents a filter for constituent custom fields modified on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $sort_token Represents a token filter to provide the next stable-sorted list of constituent custom fields. This will be provided on the next_link collection response property when last_modified or sort_token filters are specified on the request. (optional)
     * @param  string $category Represents a filter for custom field categories. Returns any custom fields that match the specified category. For example, &lt;i&gt;category&#x3D;Interests&lt;/i&gt; returns custom fields with the &lt;i&gt;Interests&lt;/i&gt; category. (optional)
     * @param  string $value Represents a filter for custom field values. Must be used in conjunction with the &lt;code&gt;category&lt;/code&gt; filter. Returns any custom fields in the specified category that match any of the specified values. For example, &lt;i&gt;category&#x3D;Interests&amp;amp;value&#x3D;Baseball&amp;amp;value&#x3D;Tennis&lt;/i&gt; returns &lt;i&gt;Interests&lt;/i&gt; custom fields with the &lt;i&gt;Baseball&lt;/i&gt; or &lt;i&gt;Tennis&lt;/i&gt; values. Filtering by fuzzy date values must be in one of the following formats: &lt;i&gt;YYYYMMDD&lt;/i&gt;, &lt;i&gt;YYYY&lt;/i&gt;, &lt;i&gt;YYYYMM&lt;/i&gt;, or &lt;i&gt;MMDD&lt;/i&gt;.  Any four digit value that starts with 13 or higher will be considered a year.  Any four digit value that starts with 01-12 will be considered to be in &lt;i&gt;MMDD&lt;/i&gt; format. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listConstituentCustomFieldsAllConstituentsRequest($date_added = null, $last_modified = null, $sort_token = null, $category = null, $value = null, $limit = null, $offset = null)
    {

        $resourcePath = '/constituents/customfields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($date_added)) {
            $date_added = ObjectSerializer::serializeCollection($date_added, '', true);
        }
        if ($date_added !== null) {
            $queryParams['date_added'] = $date_added;
        }
        // query params
        if (is_array($last_modified)) {
            $last_modified = ObjectSerializer::serializeCollection($last_modified, '', true);
        }
        if ($last_modified !== null) {
            $queryParams['last_modified'] = $last_modified;
        }
        // query params
        if (is_array($sort_token)) {
            $sort_token = ObjectSerializer::serializeCollection($sort_token, '', true);
        }
        if ($sort_token !== null) {
            $queryParams['sort_token'] = $sort_token;
        }
        // query params
        if (is_array($category)) {
            $category = ObjectSerializer::serializeCollection($category, '', true);
        }
        if ($category !== null) {
            $queryParams['category'] = $category;
        }
        // query params
        if (is_array($value)) {
            $value = ObjectSerializer::serializeCollection($value, '', true);
        }
        if ($value !== null) {
            $queryParams['value'] = $value;
        }
        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }
        // query params
        if (is_array($offset)) {
            $offset = ObjectSerializer::serializeCollection($offset, '', true);
        }
        if ($offset !== null) {
            $queryParams['offset'] = $offset;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listConstituentCustomFieldsSingleConstituent
     *
     * Constituent custom field list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the custom fields for. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionCustomFieldRead
     */
    public function listConstituentCustomFieldsSingleConstituent($constituent_id)
    {
        list($response) = $this->listConstituentCustomFieldsSingleConstituentWithHttpInfo($constituent_id);
        return $response;
    }

    /**
     * Operation listConstituentCustomFieldsSingleConstituentWithHttpInfo
     *
     * Constituent custom field list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the custom fields for. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionCustomFieldRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConstituentCustomFieldsSingleConstituentWithHttpInfo($constituent_id)
    {
        $request = $this->listConstituentCustomFieldsSingleConstituentRequest($constituent_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionCustomFieldRead' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionCustomFieldRead', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionCustomFieldRead';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionCustomFieldRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConstituentCustomFieldsSingleConstituentAsync
     *
     * Constituent custom field list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the custom fields for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentCustomFieldsSingleConstituentAsync($constituent_id)
    {
        return $this->listConstituentCustomFieldsSingleConstituentAsyncWithHttpInfo($constituent_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConstituentCustomFieldsSingleConstituentAsyncWithHttpInfo
     *
     * Constituent custom field list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the custom fields for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentCustomFieldsSingleConstituentAsyncWithHttpInfo($constituent_id)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionCustomFieldRead';
        $request = $this->listConstituentCustomFieldsSingleConstituentRequest($constituent_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listConstituentCustomFieldsSingleConstituent'
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the custom fields for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listConstituentCustomFieldsSingleConstituentRequest($constituent_id)
    {
        // verify the required parameter 'constituent_id' is set
        if ($constituent_id === null || (is_array($constituent_id) && count($constituent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $constituent_id when calling listConstituentCustomFieldsSingleConstituent'
            );
        }

        $resourcePath = '/constituents/{constituent_id}/customfields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($constituent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'constituent_id' . '}',
                ObjectSerializer::toPathValue($constituent_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listConstituentFundraiserAssignmentsSingleConstituent
     *
     * Fundraiser assignment list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the fundraiser assignments for. (required)
     * @param  bool $include_inactive Set this parameter to \&quot;false\&quot; to exclude inactive fundraiser assignments in the response. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionFundraiserAssignmentRead
     */
    public function listConstituentFundraiserAssignmentsSingleConstituent($constituent_id, $include_inactive = null)
    {
        list($response) = $this->listConstituentFundraiserAssignmentsSingleConstituentWithHttpInfo($constituent_id, $include_inactive);
        return $response;
    }

    /**
     * Operation listConstituentFundraiserAssignmentsSingleConstituentWithHttpInfo
     *
     * Fundraiser assignment list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the fundraiser assignments for. (required)
     * @param  bool $include_inactive Set this parameter to \&quot;false\&quot; to exclude inactive fundraiser assignments in the response. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionFundraiserAssignmentRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConstituentFundraiserAssignmentsSingleConstituentWithHttpInfo($constituent_id, $include_inactive = null)
    {
        $request = $this->listConstituentFundraiserAssignmentsSingleConstituentRequest($constituent_id, $include_inactive);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionFundraiserAssignmentRead' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionFundraiserAssignmentRead', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionFundraiserAssignmentRead';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionFundraiserAssignmentRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConstituentFundraiserAssignmentsSingleConstituentAsync
     *
     * Fundraiser assignment list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the fundraiser assignments for. (required)
     * @param  bool $include_inactive Set this parameter to \&quot;false\&quot; to exclude inactive fundraiser assignments in the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentFundraiserAssignmentsSingleConstituentAsync($constituent_id, $include_inactive = null)
    {
        return $this->listConstituentFundraiserAssignmentsSingleConstituentAsyncWithHttpInfo($constituent_id, $include_inactive)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConstituentFundraiserAssignmentsSingleConstituentAsyncWithHttpInfo
     *
     * Fundraiser assignment list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the fundraiser assignments for. (required)
     * @param  bool $include_inactive Set this parameter to \&quot;false\&quot; to exclude inactive fundraiser assignments in the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentFundraiserAssignmentsSingleConstituentAsyncWithHttpInfo($constituent_id, $include_inactive = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionFundraiserAssignmentRead';
        $request = $this->listConstituentFundraiserAssignmentsSingleConstituentRequest($constituent_id, $include_inactive);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listConstituentFundraiserAssignmentsSingleConstituent'
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the fundraiser assignments for. (required)
     * @param  bool $include_inactive Set this parameter to \&quot;false\&quot; to exclude inactive fundraiser assignments in the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listConstituentFundraiserAssignmentsSingleConstituentRequest($constituent_id, $include_inactive = null)
    {
        // verify the required parameter 'constituent_id' is set
        if ($constituent_id === null || (is_array($constituent_id) && count($constituent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $constituent_id when calling listConstituentFundraiserAssignmentsSingleConstituent'
            );
        }

        $resourcePath = '/constituents/{constituent_id}/fundraiserassignments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($include_inactive)) {
            $include_inactive = ObjectSerializer::serializeCollection($include_inactive, '', true);
        }
        if ($include_inactive !== null) {
            $queryParams['include_inactive'] = $include_inactive;
        }


        // path params
        if ($constituent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'constituent_id' . '}',
                ObjectSerializer::toPathValue($constituent_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listConstituentFundraisersSingleConstituent
     *
     * Fundraiser list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the fundraisers for. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionConstituentFundraiserRead
     */
    public function listConstituentFundraisersSingleConstituent($constituent_id)
    {
        list($response) = $this->listConstituentFundraisersSingleConstituentWithHttpInfo($constituent_id);
        return $response;
    }

    /**
     * Operation listConstituentFundraisersSingleConstituentWithHttpInfo
     *
     * Fundraiser list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the fundraisers for. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionConstituentFundraiserRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConstituentFundraisersSingleConstituentWithHttpInfo($constituent_id)
    {
        $request = $this->listConstituentFundraisersSingleConstituentRequest($constituent_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionConstituentFundraiserRead' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionConstituentFundraiserRead', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionConstituentFundraiserRead';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionConstituentFundraiserRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConstituentFundraisersSingleConstituentAsync
     *
     * Fundraiser list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the fundraisers for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentFundraisersSingleConstituentAsync($constituent_id)
    {
        return $this->listConstituentFundraisersSingleConstituentAsyncWithHttpInfo($constituent_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConstituentFundraisersSingleConstituentAsyncWithHttpInfo
     *
     * Fundraiser list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the fundraisers for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentFundraisersSingleConstituentAsyncWithHttpInfo($constituent_id)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionConstituentFundraiserRead';
        $request = $this->listConstituentFundraisersSingleConstituentRequest($constituent_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listConstituentFundraisersSingleConstituent'
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the fundraisers for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listConstituentFundraisersSingleConstituentRequest($constituent_id)
    {
        // verify the required parameter 'constituent_id' is set
        if ($constituent_id === null || (is_array($constituent_id) && count($constituent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $constituent_id when calling listConstituentFundraisersSingleConstituent'
            );
        }

        $resourcePath = '/constituents/{constituent_id}/fundraisers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($constituent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'constituent_id' . '}',
                ObjectSerializer::toPathValue($constituent_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listConstituents
     *
     * Constituent list
     *
     * @param  string $constituent_code Represents a list of constituent codes. Returns constituents if any of the specified constituent codes match any of their active constituent codes. For example, \&quot;constituent_code&#x3D;Board Member&amp;amp;constituent_code&#x3D;Volunteer\&quot; returns constituents with either \&quot;Board Member\&quot; or \&quot;Volunteer\&quot; constituent codes. (optional)
     * @param  string $constituent_id Represents a list of constituent identifiers. Returns constituents if any of the specified constituent identifiers match any of their constituents. For example, \&quot;constituent_id&#x3D;280&amp;amp;constituent_id&#x3D;1232\&quot; returns constituents with either \&quot;280\&quot; or \&quot;1232\&quot; constituent identifiers. (optional)
     * @param  string $custom_field_category Represents a list of custom field categories. Returns constituents if any of the specified custom field categories match any of their active custom fields. For example, \&quot;custom_field_category&#x3D;Interests&amp;amp;custom_field_category&#x3D;Anniversary\&quot; returns constituents with either \&quot;Interests\&quot; or \&quot;Anniversary\&quot; custom fields. (optional)
     * @param  string $fields Represents the fields to include on the returned records. For example, \&quot;fields&#x3D;id,first,last,deceased_date\&quot;. The &lt;code&gt;id&lt;/code&gt; field will always be returned. (optional)
     * @param  string $fundraiser_status Represents a comma-separated list of fundraiser statuses. Returns constituents if any of the specified fundraiser statuses match the constituent&#39;s fundraiser status. For example, \&quot;fundraiser_status&#x3D;Active,None\&quot; returns constituents whose fundraiser status that matches Active or None.  Valid values for this filter are Active, Inactive, and None. (optional)
     * @param  bool $include_deceased Set this parameter to \&quot;true\&quot; to include deceased constituents in the response. (optional)
     * @param  bool $include_inactive Set this parameter to \&quot;true\&quot; to include inactive constituents in the response. (optional)
     * @param  string $list_id Defines a list identifier used to filter the set of constituents to those included in the specified list. If this value is set, other specified filters will be ignored. (optional)
     * @param  string $postal_code Represents a comma-separated list of postal codes. Returns constituents if any of the specified postal codes match the postal code for their preferred address. For example, \&quot;postal_code&#x3D;99577,14623\&quot; returns constituents whose preferred address has a postal code that matches or starts with 99577 or 14623, such as 99577, 14623, or 99577-0727. (optional)
     * @param  string $date_added Format - date-time (as date-time in RFC3339). Represents a filter for results created on or after the specified date. Adds the sort_token parameter to the next_link URL to ensure that constituents are stably sorted. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $last_modified Format - date-time (as date-time in RFC3339). Represents a filter for results modified on or after the specified date. Adds the sort_token parameter to the next_link URL to ensure that constituents are stably sorted. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $sort_token Represents a token filter to provide the next stable-sorted list of results and to ensure that the order persists even if changes occur while working through a paginated list. The token is provided on the next_link collection response property when the request specifies the sort_token filter. The last_modified, date_added, and sort parameters also add the token to the next_link URL, although the sort parameter only adds the token when it sorts by just the date_added field or just the date_modified field. (optional)
     * @param  string $sort Represents a list of fields to sort the results by. Returns a list that sorts constituents based on the supplied fields. Results are in ascending order by default, and a &#39;-&#39; sign denotes descending order. For example, \&quot;sort&#x3D;date_added,-last\&quot; sorts constituents by the \&quot;date_added\&quot; field in ascending order and then by the \&quot;last\&quot; field in descending order.  If only the date_modified field or only the date_added field is provided, then this adds the sort_token parameter to the next_link URL to ensure that constituents are stably sorted. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionConstituentListItem
     */
    public function listConstituents($constituent_code = null, $constituent_id = null, $custom_field_category = null, $fields = null, $fundraiser_status = null, $include_deceased = null, $include_inactive = null, $list_id = null, $postal_code = null, $date_added = null, $last_modified = null, $sort_token = null, $sort = null, $limit = null, $offset = null)
    {
        list($response) = $this->listConstituentsWithHttpInfo($constituent_code, $constituent_id, $custom_field_category, $fields, $fundraiser_status, $include_deceased, $include_inactive, $list_id, $postal_code, $date_added, $last_modified, $sort_token, $sort, $limit, $offset);
        return $response;
    }

    /**
     * Operation listConstituentsWithHttpInfo
     *
     * Constituent list
     *
     * @param  string $constituent_code Represents a list of constituent codes. Returns constituents if any of the specified constituent codes match any of their active constituent codes. For example, \&quot;constituent_code&#x3D;Board Member&amp;amp;constituent_code&#x3D;Volunteer\&quot; returns constituents with either \&quot;Board Member\&quot; or \&quot;Volunteer\&quot; constituent codes. (optional)
     * @param  string $constituent_id Represents a list of constituent identifiers. Returns constituents if any of the specified constituent identifiers match any of their constituents. For example, \&quot;constituent_id&#x3D;280&amp;amp;constituent_id&#x3D;1232\&quot; returns constituents with either \&quot;280\&quot; or \&quot;1232\&quot; constituent identifiers. (optional)
     * @param  string $custom_field_category Represents a list of custom field categories. Returns constituents if any of the specified custom field categories match any of their active custom fields. For example, \&quot;custom_field_category&#x3D;Interests&amp;amp;custom_field_category&#x3D;Anniversary\&quot; returns constituents with either \&quot;Interests\&quot; or \&quot;Anniversary\&quot; custom fields. (optional)
     * @param  string $fields Represents the fields to include on the returned records. For example, \&quot;fields&#x3D;id,first,last,deceased_date\&quot;. The &lt;code&gt;id&lt;/code&gt; field will always be returned. (optional)
     * @param  string $fundraiser_status Represents a comma-separated list of fundraiser statuses. Returns constituents if any of the specified fundraiser statuses match the constituent&#39;s fundraiser status. For example, \&quot;fundraiser_status&#x3D;Active,None\&quot; returns constituents whose fundraiser status that matches Active or None.  Valid values for this filter are Active, Inactive, and None. (optional)
     * @param  bool $include_deceased Set this parameter to \&quot;true\&quot; to include deceased constituents in the response. (optional)
     * @param  bool $include_inactive Set this parameter to \&quot;true\&quot; to include inactive constituents in the response. (optional)
     * @param  string $list_id Defines a list identifier used to filter the set of constituents to those included in the specified list. If this value is set, other specified filters will be ignored. (optional)
     * @param  string $postal_code Represents a comma-separated list of postal codes. Returns constituents if any of the specified postal codes match the postal code for their preferred address. For example, \&quot;postal_code&#x3D;99577,14623\&quot; returns constituents whose preferred address has a postal code that matches or starts with 99577 or 14623, such as 99577, 14623, or 99577-0727. (optional)
     * @param  string $date_added Format - date-time (as date-time in RFC3339). Represents a filter for results created on or after the specified date. Adds the sort_token parameter to the next_link URL to ensure that constituents are stably sorted. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $last_modified Format - date-time (as date-time in RFC3339). Represents a filter for results modified on or after the specified date. Adds the sort_token parameter to the next_link URL to ensure that constituents are stably sorted. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $sort_token Represents a token filter to provide the next stable-sorted list of results and to ensure that the order persists even if changes occur while working through a paginated list. The token is provided on the next_link collection response property when the request specifies the sort_token filter. The last_modified, date_added, and sort parameters also add the token to the next_link URL, although the sort parameter only adds the token when it sorts by just the date_added field or just the date_modified field. (optional)
     * @param  string $sort Represents a list of fields to sort the results by. Returns a list that sorts constituents based on the supplied fields. Results are in ascending order by default, and a &#39;-&#39; sign denotes descending order. For example, \&quot;sort&#x3D;date_added,-last\&quot; sorts constituents by the \&quot;date_added\&quot; field in ascending order and then by the \&quot;last\&quot; field in descending order.  If only the date_modified field or only the date_added field is provided, then this adds the sort_token parameter to the next_link URL to ensure that constituents are stably sorted. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionConstituentListItem, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConstituentsWithHttpInfo($constituent_code = null, $constituent_id = null, $custom_field_category = null, $fields = null, $fundraiser_status = null, $include_deceased = null, $include_inactive = null, $list_id = null, $postal_code = null, $date_added = null, $last_modified = null, $sort_token = null, $sort = null, $limit = null, $offset = null)
    {
        $request = $this->listConstituentsRequest($constituent_code, $constituent_id, $custom_field_category, $fields, $fundraiser_status, $include_deceased, $include_inactive, $list_id, $postal_code, $date_added, $last_modified, $sort_token, $sort, $limit, $offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionConstituentListItem' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionConstituentListItem', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionConstituentListItem';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionConstituentListItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConstituentsAsync
     *
     * Constituent list
     *
     * @param  string $constituent_code Represents a list of constituent codes. Returns constituents if any of the specified constituent codes match any of their active constituent codes. For example, \&quot;constituent_code&#x3D;Board Member&amp;amp;constituent_code&#x3D;Volunteer\&quot; returns constituents with either \&quot;Board Member\&quot; or \&quot;Volunteer\&quot; constituent codes. (optional)
     * @param  string $constituent_id Represents a list of constituent identifiers. Returns constituents if any of the specified constituent identifiers match any of their constituents. For example, \&quot;constituent_id&#x3D;280&amp;amp;constituent_id&#x3D;1232\&quot; returns constituents with either \&quot;280\&quot; or \&quot;1232\&quot; constituent identifiers. (optional)
     * @param  string $custom_field_category Represents a list of custom field categories. Returns constituents if any of the specified custom field categories match any of their active custom fields. For example, \&quot;custom_field_category&#x3D;Interests&amp;amp;custom_field_category&#x3D;Anniversary\&quot; returns constituents with either \&quot;Interests\&quot; or \&quot;Anniversary\&quot; custom fields. (optional)
     * @param  string $fields Represents the fields to include on the returned records. For example, \&quot;fields&#x3D;id,first,last,deceased_date\&quot;. The &lt;code&gt;id&lt;/code&gt; field will always be returned. (optional)
     * @param  string $fundraiser_status Represents a comma-separated list of fundraiser statuses. Returns constituents if any of the specified fundraiser statuses match the constituent&#39;s fundraiser status. For example, \&quot;fundraiser_status&#x3D;Active,None\&quot; returns constituents whose fundraiser status that matches Active or None.  Valid values for this filter are Active, Inactive, and None. (optional)
     * @param  bool $include_deceased Set this parameter to \&quot;true\&quot; to include deceased constituents in the response. (optional)
     * @param  bool $include_inactive Set this parameter to \&quot;true\&quot; to include inactive constituents in the response. (optional)
     * @param  string $list_id Defines a list identifier used to filter the set of constituents to those included in the specified list. If this value is set, other specified filters will be ignored. (optional)
     * @param  string $postal_code Represents a comma-separated list of postal codes. Returns constituents if any of the specified postal codes match the postal code for their preferred address. For example, \&quot;postal_code&#x3D;99577,14623\&quot; returns constituents whose preferred address has a postal code that matches or starts with 99577 or 14623, such as 99577, 14623, or 99577-0727. (optional)
     * @param  string $date_added Format - date-time (as date-time in RFC3339). Represents a filter for results created on or after the specified date. Adds the sort_token parameter to the next_link URL to ensure that constituents are stably sorted. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $last_modified Format - date-time (as date-time in RFC3339). Represents a filter for results modified on or after the specified date. Adds the sort_token parameter to the next_link URL to ensure that constituents are stably sorted. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $sort_token Represents a token filter to provide the next stable-sorted list of results and to ensure that the order persists even if changes occur while working through a paginated list. The token is provided on the next_link collection response property when the request specifies the sort_token filter. The last_modified, date_added, and sort parameters also add the token to the next_link URL, although the sort parameter only adds the token when it sorts by just the date_added field or just the date_modified field. (optional)
     * @param  string $sort Represents a list of fields to sort the results by. Returns a list that sorts constituents based on the supplied fields. Results are in ascending order by default, and a &#39;-&#39; sign denotes descending order. For example, \&quot;sort&#x3D;date_added,-last\&quot; sorts constituents by the \&quot;date_added\&quot; field in ascending order and then by the \&quot;last\&quot; field in descending order.  If only the date_modified field or only the date_added field is provided, then this adds the sort_token parameter to the next_link URL to ensure that constituents are stably sorted. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentsAsync($constituent_code = null, $constituent_id = null, $custom_field_category = null, $fields = null, $fundraiser_status = null, $include_deceased = null, $include_inactive = null, $list_id = null, $postal_code = null, $date_added = null, $last_modified = null, $sort_token = null, $sort = null, $limit = null, $offset = null)
    {
        return $this->listConstituentsAsyncWithHttpInfo($constituent_code, $constituent_id, $custom_field_category, $fields, $fundraiser_status, $include_deceased, $include_inactive, $list_id, $postal_code, $date_added, $last_modified, $sort_token, $sort, $limit, $offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConstituentsAsyncWithHttpInfo
     *
     * Constituent list
     *
     * @param  string $constituent_code Represents a list of constituent codes. Returns constituents if any of the specified constituent codes match any of their active constituent codes. For example, \&quot;constituent_code&#x3D;Board Member&amp;amp;constituent_code&#x3D;Volunteer\&quot; returns constituents with either \&quot;Board Member\&quot; or \&quot;Volunteer\&quot; constituent codes. (optional)
     * @param  string $constituent_id Represents a list of constituent identifiers. Returns constituents if any of the specified constituent identifiers match any of their constituents. For example, \&quot;constituent_id&#x3D;280&amp;amp;constituent_id&#x3D;1232\&quot; returns constituents with either \&quot;280\&quot; or \&quot;1232\&quot; constituent identifiers. (optional)
     * @param  string $custom_field_category Represents a list of custom field categories. Returns constituents if any of the specified custom field categories match any of their active custom fields. For example, \&quot;custom_field_category&#x3D;Interests&amp;amp;custom_field_category&#x3D;Anniversary\&quot; returns constituents with either \&quot;Interests\&quot; or \&quot;Anniversary\&quot; custom fields. (optional)
     * @param  string $fields Represents the fields to include on the returned records. For example, \&quot;fields&#x3D;id,first,last,deceased_date\&quot;. The &lt;code&gt;id&lt;/code&gt; field will always be returned. (optional)
     * @param  string $fundraiser_status Represents a comma-separated list of fundraiser statuses. Returns constituents if any of the specified fundraiser statuses match the constituent&#39;s fundraiser status. For example, \&quot;fundraiser_status&#x3D;Active,None\&quot; returns constituents whose fundraiser status that matches Active or None.  Valid values for this filter are Active, Inactive, and None. (optional)
     * @param  bool $include_deceased Set this parameter to \&quot;true\&quot; to include deceased constituents in the response. (optional)
     * @param  bool $include_inactive Set this parameter to \&quot;true\&quot; to include inactive constituents in the response. (optional)
     * @param  string $list_id Defines a list identifier used to filter the set of constituents to those included in the specified list. If this value is set, other specified filters will be ignored. (optional)
     * @param  string $postal_code Represents a comma-separated list of postal codes. Returns constituents if any of the specified postal codes match the postal code for their preferred address. For example, \&quot;postal_code&#x3D;99577,14623\&quot; returns constituents whose preferred address has a postal code that matches or starts with 99577 or 14623, such as 99577, 14623, or 99577-0727. (optional)
     * @param  string $date_added Format - date-time (as date-time in RFC3339). Represents a filter for results created on or after the specified date. Adds the sort_token parameter to the next_link URL to ensure that constituents are stably sorted. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $last_modified Format - date-time (as date-time in RFC3339). Represents a filter for results modified on or after the specified date. Adds the sort_token parameter to the next_link URL to ensure that constituents are stably sorted. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $sort_token Represents a token filter to provide the next stable-sorted list of results and to ensure that the order persists even if changes occur while working through a paginated list. The token is provided on the next_link collection response property when the request specifies the sort_token filter. The last_modified, date_added, and sort parameters also add the token to the next_link URL, although the sort parameter only adds the token when it sorts by just the date_added field or just the date_modified field. (optional)
     * @param  string $sort Represents a list of fields to sort the results by. Returns a list that sorts constituents based on the supplied fields. Results are in ascending order by default, and a &#39;-&#39; sign denotes descending order. For example, \&quot;sort&#x3D;date_added,-last\&quot; sorts constituents by the \&quot;date_added\&quot; field in ascending order and then by the \&quot;last\&quot; field in descending order.  If only the date_modified field or only the date_added field is provided, then this adds the sort_token parameter to the next_link URL to ensure that constituents are stably sorted. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentsAsyncWithHttpInfo($constituent_code = null, $constituent_id = null, $custom_field_category = null, $fields = null, $fundraiser_status = null, $include_deceased = null, $include_inactive = null, $list_id = null, $postal_code = null, $date_added = null, $last_modified = null, $sort_token = null, $sort = null, $limit = null, $offset = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionConstituentListItem';
        $request = $this->listConstituentsRequest($constituent_code, $constituent_id, $custom_field_category, $fields, $fundraiser_status, $include_deceased, $include_inactive, $list_id, $postal_code, $date_added, $last_modified, $sort_token, $sort, $limit, $offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listConstituents'
     *
     * @param  string $constituent_code Represents a list of constituent codes. Returns constituents if any of the specified constituent codes match any of their active constituent codes. For example, \&quot;constituent_code&#x3D;Board Member&amp;amp;constituent_code&#x3D;Volunteer\&quot; returns constituents with either \&quot;Board Member\&quot; or \&quot;Volunteer\&quot; constituent codes. (optional)
     * @param  string $constituent_id Represents a list of constituent identifiers. Returns constituents if any of the specified constituent identifiers match any of their constituents. For example, \&quot;constituent_id&#x3D;280&amp;amp;constituent_id&#x3D;1232\&quot; returns constituents with either \&quot;280\&quot; or \&quot;1232\&quot; constituent identifiers. (optional)
     * @param  string $custom_field_category Represents a list of custom field categories. Returns constituents if any of the specified custom field categories match any of their active custom fields. For example, \&quot;custom_field_category&#x3D;Interests&amp;amp;custom_field_category&#x3D;Anniversary\&quot; returns constituents with either \&quot;Interests\&quot; or \&quot;Anniversary\&quot; custom fields. (optional)
     * @param  string $fields Represents the fields to include on the returned records. For example, \&quot;fields&#x3D;id,first,last,deceased_date\&quot;. The &lt;code&gt;id&lt;/code&gt; field will always be returned. (optional)
     * @param  string $fundraiser_status Represents a comma-separated list of fundraiser statuses. Returns constituents if any of the specified fundraiser statuses match the constituent&#39;s fundraiser status. For example, \&quot;fundraiser_status&#x3D;Active,None\&quot; returns constituents whose fundraiser status that matches Active or None.  Valid values for this filter are Active, Inactive, and None. (optional)
     * @param  bool $include_deceased Set this parameter to \&quot;true\&quot; to include deceased constituents in the response. (optional)
     * @param  bool $include_inactive Set this parameter to \&quot;true\&quot; to include inactive constituents in the response. (optional)
     * @param  string $list_id Defines a list identifier used to filter the set of constituents to those included in the specified list. If this value is set, other specified filters will be ignored. (optional)
     * @param  string $postal_code Represents a comma-separated list of postal codes. Returns constituents if any of the specified postal codes match the postal code for their preferred address. For example, \&quot;postal_code&#x3D;99577,14623\&quot; returns constituents whose preferred address has a postal code that matches or starts with 99577 or 14623, such as 99577, 14623, or 99577-0727. (optional)
     * @param  string $date_added Format - date-time (as date-time in RFC3339). Represents a filter for results created on or after the specified date. Adds the sort_token parameter to the next_link URL to ensure that constituents are stably sorted. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $last_modified Format - date-time (as date-time in RFC3339). Represents a filter for results modified on or after the specified date. Adds the sort_token parameter to the next_link URL to ensure that constituents are stably sorted. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $sort_token Represents a token filter to provide the next stable-sorted list of results and to ensure that the order persists even if changes occur while working through a paginated list. The token is provided on the next_link collection response property when the request specifies the sort_token filter. The last_modified, date_added, and sort parameters also add the token to the next_link URL, although the sort parameter only adds the token when it sorts by just the date_added field or just the date_modified field. (optional)
     * @param  string $sort Represents a list of fields to sort the results by. Returns a list that sorts constituents based on the supplied fields. Results are in ascending order by default, and a &#39;-&#39; sign denotes descending order. For example, \&quot;sort&#x3D;date_added,-last\&quot; sorts constituents by the \&quot;date_added\&quot; field in ascending order and then by the \&quot;last\&quot; field in descending order.  If only the date_modified field or only the date_added field is provided, then this adds the sort_token parameter to the next_link URL to ensure that constituents are stably sorted. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listConstituentsRequest($constituent_code = null, $constituent_id = null, $custom_field_category = null, $fields = null, $fundraiser_status = null, $include_deceased = null, $include_inactive = null, $list_id = null, $postal_code = null, $date_added = null, $last_modified = null, $sort_token = null, $sort = null, $limit = null, $offset = null)
    {

        $resourcePath = '/constituents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($constituent_code)) {
            $constituent_code = ObjectSerializer::serializeCollection($constituent_code, '', true);
        }
        if ($constituent_code !== null) {
            $queryParams['constituent_code'] = $constituent_code;
        }
        // query params
        if (is_array($constituent_id)) {
            $constituent_id = ObjectSerializer::serializeCollection($constituent_id, '', true);
        }
        if ($constituent_id !== null) {
            $queryParams['constituent_id'] = $constituent_id;
        }
        // query params
        if (is_array($custom_field_category)) {
            $custom_field_category = ObjectSerializer::serializeCollection($custom_field_category, '', true);
        }
        if ($custom_field_category !== null) {
            $queryParams['custom_field_category'] = $custom_field_category;
        }
        // query params
        if (is_array($fields)) {
            $fields = ObjectSerializer::serializeCollection($fields, '', true);
        }
        if ($fields !== null) {
            $queryParams['fields'] = $fields;
        }
        // query params
        if (is_array($fundraiser_status)) {
            $fundraiser_status = ObjectSerializer::serializeCollection($fundraiser_status, '', true);
        }
        if ($fundraiser_status !== null) {
            $queryParams['fundraiser_status'] = $fundraiser_status;
        }
        // query params
        if (is_array($include_deceased)) {
            $include_deceased = ObjectSerializer::serializeCollection($include_deceased, '', true);
        }
        if ($include_deceased !== null) {
            $queryParams['include_deceased'] = $include_deceased;
        }
        // query params
        if (is_array($include_inactive)) {
            $include_inactive = ObjectSerializer::serializeCollection($include_inactive, '', true);
        }
        if ($include_inactive !== null) {
            $queryParams['include_inactive'] = $include_inactive;
        }
        // query params
        if (is_array($list_id)) {
            $list_id = ObjectSerializer::serializeCollection($list_id, '', true);
        }
        if ($list_id !== null) {
            $queryParams['list_id'] = $list_id;
        }
        // query params
        if (is_array($postal_code)) {
            $postal_code = ObjectSerializer::serializeCollection($postal_code, '', true);
        }
        if ($postal_code !== null) {
            $queryParams['postal_code'] = $postal_code;
        }
        // query params
        if (is_array($date_added)) {
            $date_added = ObjectSerializer::serializeCollection($date_added, '', true);
        }
        if ($date_added !== null) {
            $queryParams['date_added'] = $date_added;
        }
        // query params
        if (is_array($last_modified)) {
            $last_modified = ObjectSerializer::serializeCollection($last_modified, '', true);
        }
        if ($last_modified !== null) {
            $queryParams['last_modified'] = $last_modified;
        }
        // query params
        if (is_array($sort_token)) {
            $sort_token = ObjectSerializer::serializeCollection($sort_token, '', true);
        }
        if ($sort_token !== null) {
            $queryParams['sort_token'] = $sort_token;
        }
        // query params
        if (is_array($sort)) {
            $sort = ObjectSerializer::serializeCollection($sort, '', true);
        }
        if ($sort !== null) {
            $queryParams['sort'] = $sort;
        }
        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }
        // query params
        if (is_array($offset)) {
            $offset = ObjectSerializer::serializeCollection($offset, '', true);
        }
        if ($offset !== null) {
            $queryParams['offset'] = $offset;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listGenders
     *
     * Genders
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString
     */
    public function listGenders()
    {
        list($response) = $this->listGendersWithHttpInfo();
        return $response;
    }

    /**
     * Operation listGendersWithHttpInfo
     *
     * Genders
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString, HTTP status code, HTTP response headers (array of strings)
     */
    public function listGendersWithHttpInfo()
    {
        $request = $this->listGendersRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listGendersAsync
     *
     * Genders
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listGendersAsync()
    {
        return $this->listGendersAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listGendersAsyncWithHttpInfo
     *
     * Genders
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listGendersAsyncWithHttpInfo()
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString';
        $request = $this->listGendersRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listGenders'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listGendersRequest()
    {

        $resourcePath = '/genders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMaritalStatuses
     *
     * Marital statuses
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString
     */
    public function listMaritalStatuses()
    {
        list($response) = $this->listMaritalStatusesWithHttpInfo();
        return $response;
    }

    /**
     * Operation listMaritalStatusesWithHttpInfo
     *
     * Marital statuses
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString, HTTP status code, HTTP response headers (array of strings)
     */
    public function listMaritalStatusesWithHttpInfo()
    {
        $request = $this->listMaritalStatusesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listMaritalStatusesAsync
     *
     * Marital statuses
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMaritalStatusesAsync()
    {
        return $this->listMaritalStatusesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMaritalStatusesAsyncWithHttpInfo
     *
     * Marital statuses
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMaritalStatusesAsyncWithHttpInfo()
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString';
        $request = $this->listMaritalStatusesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listMaritalStatuses'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listMaritalStatusesRequest()
    {

        $resourcePath = '/maritalstatuses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listSuffixes
     *
     * Suffixes
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString
     */
    public function listSuffixes()
    {
        list($response) = $this->listSuffixesWithHttpInfo();
        return $response;
    }

    /**
     * Operation listSuffixesWithHttpInfo
     *
     * Suffixes
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString, HTTP status code, HTTP response headers (array of strings)
     */
    public function listSuffixesWithHttpInfo()
    {
        $request = $this->listSuffixesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listSuffixesAsync
     *
     * Suffixes
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listSuffixesAsync()
    {
        return $this->listSuffixesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listSuffixesAsyncWithHttpInfo
     *
     * Suffixes
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listSuffixesAsyncWithHttpInfo()
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString';
        $request = $this->listSuffixesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listSuffixes'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listSuffixesRequest()
    {

        $resourcePath = '/suffixes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listTitles
     *
     * Titles
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString
     */
    public function listTitles()
    {
        list($response) = $this->listTitlesWithHttpInfo();
        return $response;
    }

    /**
     * Operation listTitlesWithHttpInfo
     *
     * Titles
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString, HTTP status code, HTTP response headers (array of strings)
     */
    public function listTitlesWithHttpInfo()
    {
        $request = $this->listTitlesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listTitlesAsync
     *
     * Titles
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTitlesAsync()
    {
        return $this->listTitlesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listTitlesAsyncWithHttpInfo
     *
     * Titles
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTitlesAsyncWithHttpInfo()
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionString';
        $request = $this->listTitlesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listTitles'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listTitlesRequest()
    {

        $resourcePath = '/titles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchConstituentProfilePicture
     *
     * Profile picture
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to update for the current profile picture. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\ProfilePictureEdit $profile_picture_edit An object that represents the properties for the constituent picture to update. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function patchConstituentProfilePicture($constituent_id, $profile_picture_edit = null)
    {
        $this->patchConstituentProfilePictureWithHttpInfo($constituent_id, $profile_picture_edit);
    }

    /**
     * Operation patchConstituentProfilePictureWithHttpInfo
     *
     * Profile picture
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to update for the current profile picture. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\ProfilePictureEdit $profile_picture_edit An object that represents the properties for the constituent picture to update. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchConstituentProfilePictureWithHttpInfo($constituent_id, $profile_picture_edit = null)
    {
        $request = $this->patchConstituentProfilePictureRequest($constituent_id, $profile_picture_edit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation patchConstituentProfilePictureAsync
     *
     * Profile picture
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to update for the current profile picture. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\ProfilePictureEdit $profile_picture_edit An object that represents the properties for the constituent picture to update. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchConstituentProfilePictureAsync($constituent_id, $profile_picture_edit = null)
    {
        return $this->patchConstituentProfilePictureAsyncWithHttpInfo($constituent_id, $profile_picture_edit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchConstituentProfilePictureAsyncWithHttpInfo
     *
     * Profile picture
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to update for the current profile picture. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\ProfilePictureEdit $profile_picture_edit An object that represents the properties for the constituent picture to update. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchConstituentProfilePictureAsyncWithHttpInfo($constituent_id, $profile_picture_edit = null)
    {
        $returnType = '';
        $request = $this->patchConstituentProfilePictureRequest($constituent_id, $profile_picture_edit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchConstituentProfilePicture'
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to update for the current profile picture. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\Model\ProfilePictureEdit $profile_picture_edit An object that represents the properties for the constituent picture to update. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patchConstituentProfilePictureRequest($constituent_id, $profile_picture_edit = null)
    {
        // verify the required parameter 'constituent_id' is set
        if ($constituent_id === null || (is_array($constituent_id) && count($constituent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $constituent_id when calling patchConstituentProfilePicture'
            );
        }

        $resourcePath = '/constituents/{constituent_id}/profilepicture';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($constituent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'constituent_id' . '}',
                ObjectSerializer::toPathValue($constituent_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($profile_picture_edit)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($profile_picture_edit));
            } else {
                $httpBody = $profile_picture_edit;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchConstituent
     *
     * Constituent (Search)
     *
     * @param  string $search_text The text to search for. If the search_text is a lookup_id, set the search_field to \&quot;lookup_id\&quot;. (required)
     * @param  string $fundraiser_status Represents a comma-separated list of fundraiser statuses. Returns constituents if any of the specified fundraiser statuses match the constituent&#39;s fundraiser status. For example, \&quot;fundraiser_status&#x3D;Active,None\&quot; returns constituents whose fundraiser status that matches Active or None.  Valid values for this filter are Active, Inactive, and None. (optional)
     * @param  bool $include_inactive Set this parameter to \&quot;true\&quot; to include inactive constituents in the response. (optional)
     * @param  string $search_field Represents a field to search on. Currently, it only supports lookup_id. If it is provided with search_text, a constituent with lookup_id that matches the search_text will be returned. (optional)
     * @param  bool $strict_search Set this parameter to \&quot;true\&quot; to exclude constituents whose names sound like the search text but are spelled differently. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionSearchResultRead
     */
    public function searchConstituent($search_text, $fundraiser_status = null, $include_inactive = null, $search_field = null, $strict_search = null, $limit = null, $offset = null)
    {
        list($response) = $this->searchConstituentWithHttpInfo($search_text, $fundraiser_status, $include_inactive, $search_field, $strict_search, $limit, $offset);
        return $response;
    }

    /**
     * Operation searchConstituentWithHttpInfo
     *
     * Constituent (Search)
     *
     * @param  string $search_text The text to search for. If the search_text is a lookup_id, set the search_field to \&quot;lookup_id\&quot;. (required)
     * @param  string $fundraiser_status Represents a comma-separated list of fundraiser statuses. Returns constituents if any of the specified fundraiser statuses match the constituent&#39;s fundraiser status. For example, \&quot;fundraiser_status&#x3D;Active,None\&quot; returns constituents whose fundraiser status that matches Active or None.  Valid values for this filter are Active, Inactive, and None. (optional)
     * @param  bool $include_inactive Set this parameter to \&quot;true\&quot; to include inactive constituents in the response. (optional)
     * @param  string $search_field Represents a field to search on. Currently, it only supports lookup_id. If it is provided with search_text, a constituent with lookup_id that matches the search_text will be returned. (optional)
     * @param  bool $strict_search Set this parameter to \&quot;true\&quot; to exclude constituents whose names sound like the search text but are spelled differently. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionSearchResultRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchConstituentWithHttpInfo($search_text, $fundraiser_status = null, $include_inactive = null, $search_field = null, $strict_search = null, $limit = null, $offset = null)
    {
        $request = $this->searchConstituentRequest($search_text, $fundraiser_status, $include_inactive, $search_field, $strict_search, $limit, $offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionSearchResultRead' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionSearchResultRead', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionSearchResultRead';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionSearchResultRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchConstituentAsync
     *
     * Constituent (Search)
     *
     * @param  string $search_text The text to search for. If the search_text is a lookup_id, set the search_field to \&quot;lookup_id\&quot;. (required)
     * @param  string $fundraiser_status Represents a comma-separated list of fundraiser statuses. Returns constituents if any of the specified fundraiser statuses match the constituent&#39;s fundraiser status. For example, \&quot;fundraiser_status&#x3D;Active,None\&quot; returns constituents whose fundraiser status that matches Active or None.  Valid values for this filter are Active, Inactive, and None. (optional)
     * @param  bool $include_inactive Set this parameter to \&quot;true\&quot; to include inactive constituents in the response. (optional)
     * @param  string $search_field Represents a field to search on. Currently, it only supports lookup_id. If it is provided with search_text, a constituent with lookup_id that matches the search_text will be returned. (optional)
     * @param  bool $strict_search Set this parameter to \&quot;true\&quot; to exclude constituents whose names sound like the search text but are spelled differently. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchConstituentAsync($search_text, $fundraiser_status = null, $include_inactive = null, $search_field = null, $strict_search = null, $limit = null, $offset = null)
    {
        return $this->searchConstituentAsyncWithHttpInfo($search_text, $fundraiser_status, $include_inactive, $search_field, $strict_search, $limit, $offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchConstituentAsyncWithHttpInfo
     *
     * Constituent (Search)
     *
     * @param  string $search_text The text to search for. If the search_text is a lookup_id, set the search_field to \&quot;lookup_id\&quot;. (required)
     * @param  string $fundraiser_status Represents a comma-separated list of fundraiser statuses. Returns constituents if any of the specified fundraiser statuses match the constituent&#39;s fundraiser status. For example, \&quot;fundraiser_status&#x3D;Active,None\&quot; returns constituents whose fundraiser status that matches Active or None.  Valid values for this filter are Active, Inactive, and None. (optional)
     * @param  bool $include_inactive Set this parameter to \&quot;true\&quot; to include inactive constituents in the response. (optional)
     * @param  string $search_field Represents a field to search on. Currently, it only supports lookup_id. If it is provided with search_text, a constituent with lookup_id that matches the search_text will be returned. (optional)
     * @param  bool $strict_search Set this parameter to \&quot;true\&quot; to exclude constituents whose names sound like the search text but are spelled differently. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchConstituentAsyncWithHttpInfo($search_text, $fundraiser_status = null, $include_inactive = null, $search_field = null, $strict_search = null, $limit = null, $offset = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\Model\ApiCollectionSearchResultRead';
        $request = $this->searchConstituentRequest($search_text, $fundraiser_status, $include_inactive, $search_field, $strict_search, $limit, $offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchConstituent'
     *
     * @param  string $search_text The text to search for. If the search_text is a lookup_id, set the search_field to \&quot;lookup_id\&quot;. (required)
     * @param  string $fundraiser_status Represents a comma-separated list of fundraiser statuses. Returns constituents if any of the specified fundraiser statuses match the constituent&#39;s fundraiser status. For example, \&quot;fundraiser_status&#x3D;Active,None\&quot; returns constituents whose fundraiser status that matches Active or None.  Valid values for this filter are Active, Inactive, and None. (optional)
     * @param  bool $include_inactive Set this parameter to \&quot;true\&quot; to include inactive constituents in the response. (optional)
     * @param  string $search_field Represents a field to search on. Currently, it only supports lookup_id. If it is provided with search_text, a constituent with lookup_id that matches the search_text will be returned. (optional)
     * @param  bool $strict_search Set this parameter to \&quot;true\&quot; to exclude constituents whose names sound like the search text but are spelled differently. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchConstituentRequest($search_text, $fundraiser_status = null, $include_inactive = null, $search_field = null, $strict_search = null, $limit = null, $offset = null)
    {
        // verify the required parameter 'search_text' is set
        if ($search_text === null || (is_array($search_text) && count($search_text) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $search_text when calling searchConstituent'
            );
        }

        $resourcePath = '/constituents/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($search_text)) {
            $search_text = ObjectSerializer::serializeCollection($search_text, '', true);
        }
        if ($search_text !== null) {
            $queryParams['search_text'] = $search_text;
        }
        // query params
        if (is_array($fundraiser_status)) {
            $fundraiser_status = ObjectSerializer::serializeCollection($fundraiser_status, '', true);
        }
        if ($fundraiser_status !== null) {
            $queryParams['fundraiser_status'] = $fundraiser_status;
        }
        // query params
        if (is_array($include_inactive)) {
            $include_inactive = ObjectSerializer::serializeCollection($include_inactive, '', true);
        }
        if ($include_inactive !== null) {
            $queryParams['include_inactive'] = $include_inactive;
        }
        // query params
        if (is_array($search_field)) {
            $search_field = ObjectSerializer::serializeCollection($search_field, '', true);
        }
        if ($search_field !== null) {
            $queryParams['search_field'] = $search_field;
        }
        // query params
        if (is_array($strict_search)) {
            $strict_search = ObjectSerializer::serializeCollection($strict_search, '', true);
        }
        if ($strict_search !== null) {
            $queryParams['strict_search'] = $strict_search;
        }
        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }
        // query params
        if (is_array($offset)) {
            $offset = ObjectSerializer::serializeCollection($offset, '', true);
        }
        if ($offset !== null) {
            $queryParams['offset'] = $offset;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
