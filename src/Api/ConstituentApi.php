<?php
/**
 * ConstituentApi
 * PHP version 5
 *
 * @category Class
 * @package  BurgerDigital\BlackbaudPhpSdk
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Constituent
 *
 * This API manages constituent information and related entities such as addresses, phones, emails, and notes.
 *
 * OpenAPI spec version: 1.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.24
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use BurgerDigital\BlackbaudPhpSdk\ApiException;
use BurgerDigital\BlackbaudPhpSdk\Configuration;
use BurgerDigital\BlackbaudPhpSdk\HeaderSelector;
use BurgerDigital\BlackbaudPhpSdk\ObjectSerializer;

/**
 * ConstituentApi Class Doc Comment
 *
 * @category Class
 * @package  BurgerDigital\BlackbaudPhpSdk
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ConstituentApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createConstituent
     *
     * Constituent (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ConstituentAdd $body An object that represents the constituent to create. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\PostResponse
     */
    public function createConstituent($body = null)
    {
        list($response) = $this->createConstituentWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation createConstituentWithHttpInfo
     *
     * Constituent (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ConstituentAdd $body An object that represents the constituent to create. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\PostResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createConstituentWithHttpInfo($body = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\PostResponse';
        $request = $this->createConstituentRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\PostResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createConstituentAsync
     *
     * Constituent (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ConstituentAdd $body An object that represents the constituent to create. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConstituentAsync($body = null)
    {
        return $this->createConstituentAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createConstituentAsyncWithHttpInfo
     *
     * Constituent (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ConstituentAdd $body An object that represents the constituent to create. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConstituentAsyncWithHttpInfo($body = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\PostResponse';
        $request = $this->createConstituentRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createConstituent'
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ConstituentAdd $body An object that represents the constituent to create. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createConstituentRequest($body = null)
    {

        $resourcePath = '/constituents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createConstituentAttachment
     *
     * Constituent attachment (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\AttachmentAdd $body An object that represents the attachment to create. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\PostResponse
     */
    public function createConstituentAttachment($body = null)
    {
        list($response) = $this->createConstituentAttachmentWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation createConstituentAttachmentWithHttpInfo
     *
     * Constituent attachment (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\AttachmentAdd $body An object that represents the attachment to create. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\PostResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createConstituentAttachmentWithHttpInfo($body = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\PostResponse';
        $request = $this->createConstituentAttachmentRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\PostResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createConstituentAttachmentAsync
     *
     * Constituent attachment (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\AttachmentAdd $body An object that represents the attachment to create. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConstituentAttachmentAsync($body = null)
    {
        return $this->createConstituentAttachmentAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createConstituentAttachmentAsyncWithHttpInfo
     *
     * Constituent attachment (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\AttachmentAdd $body An object that represents the attachment to create. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConstituentAttachmentAsyncWithHttpInfo($body = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\PostResponse';
        $request = $this->createConstituentAttachmentRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createConstituentAttachment'
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\AttachmentAdd $body An object that represents the attachment to create. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createConstituentAttachmentRequest($body = null)
    {

        $resourcePath = '/constituents/attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createConstituentCode
     *
     * Constituent code (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ConstituentCodeAdd $body An object that represents the constituent code to create. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\PostResponse
     */
    public function createConstituentCode($body = null)
    {
        list($response) = $this->createConstituentCodeWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation createConstituentCodeWithHttpInfo
     *
     * Constituent code (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ConstituentCodeAdd $body An object that represents the constituent code to create. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\PostResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createConstituentCodeWithHttpInfo($body = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\PostResponse';
        $request = $this->createConstituentCodeRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\PostResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createConstituentCodeAsync
     *
     * Constituent code (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ConstituentCodeAdd $body An object that represents the constituent code to create. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConstituentCodeAsync($body = null)
    {
        return $this->createConstituentCodeAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createConstituentCodeAsyncWithHttpInfo
     *
     * Constituent code (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ConstituentCodeAdd $body An object that represents the constituent code to create. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConstituentCodeAsyncWithHttpInfo($body = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\PostResponse';
        $request = $this->createConstituentCodeRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createConstituentCode'
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ConstituentCodeAdd $body An object that represents the constituent code to create. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createConstituentCodeRequest($body = null)
    {

        $resourcePath = '/constituentcodes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createConstituentCustomField
     *
     * Constituent custom field (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\CustomFieldAdd $body An object that represents the custom field to create. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\PostResponse
     */
    public function createConstituentCustomField($body = null)
    {
        list($response) = $this->createConstituentCustomFieldWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation createConstituentCustomFieldWithHttpInfo
     *
     * Constituent custom field (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\CustomFieldAdd $body An object that represents the custom field to create. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\PostResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createConstituentCustomFieldWithHttpInfo($body = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\PostResponse';
        $request = $this->createConstituentCustomFieldRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\PostResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createConstituentCustomFieldAsync
     *
     * Constituent custom field (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\CustomFieldAdd $body An object that represents the custom field to create. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConstituentCustomFieldAsync($body = null)
    {
        return $this->createConstituentCustomFieldAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createConstituentCustomFieldAsyncWithHttpInfo
     *
     * Constituent custom field (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\CustomFieldAdd $body An object that represents the custom field to create. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConstituentCustomFieldAsyncWithHttpInfo($body = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\PostResponse';
        $request = $this->createConstituentCustomFieldRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createConstituentCustomField'
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\CustomFieldAdd $body An object that represents the custom field to create. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createConstituentCustomFieldRequest($body = null)
    {

        $resourcePath = '/constituents/customfields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createDocument
     *
     * Document (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\NewDocumentInfo $body An object that represents the document to upload. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\FileDefinition
     */
    public function createDocument($body = null)
    {
        list($response) = $this->createDocumentWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation createDocumentWithHttpInfo
     *
     * Document (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\NewDocumentInfo $body An object that represents the document to upload. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\FileDefinition, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDocumentWithHttpInfo($body = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\FileDefinition';
        $request = $this->createDocumentRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\FileDefinition',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createDocumentAsync
     *
     * Document (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\NewDocumentInfo $body An object that represents the document to upload. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDocumentAsync($body = null)
    {
        return $this->createDocumentAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDocumentAsyncWithHttpInfo
     *
     * Document (Create)
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\NewDocumentInfo $body An object that represents the document to upload. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDocumentAsyncWithHttpInfo($body = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\FileDefinition';
        $request = $this->createDocumentRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDocument'
     *
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\NewDocumentInfo $body An object that represents the document to upload. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createDocumentRequest($body = null)
    {

        $resourcePath = '/documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteConstituentAttachment
     *
     * Constituent attachment (Delete)
     *
     * @param  string $attachment_id The immutable system record ID of the attachment to delete. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteConstituentAttachment($attachment_id)
    {
        $this->deleteConstituentAttachmentWithHttpInfo($attachment_id);
    }

    /**
     * Operation deleteConstituentAttachmentWithHttpInfo
     *
     * Constituent attachment (Delete)
     *
     * @param  string $attachment_id The immutable system record ID of the attachment to delete. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteConstituentAttachmentWithHttpInfo($attachment_id)
    {
        $returnType = '';
        $request = $this->deleteConstituentAttachmentRequest($attachment_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteConstituentAttachmentAsync
     *
     * Constituent attachment (Delete)
     *
     * @param  string $attachment_id The immutable system record ID of the attachment to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteConstituentAttachmentAsync($attachment_id)
    {
        return $this->deleteConstituentAttachmentAsyncWithHttpInfo($attachment_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteConstituentAttachmentAsyncWithHttpInfo
     *
     * Constituent attachment (Delete)
     *
     * @param  string $attachment_id The immutable system record ID of the attachment to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteConstituentAttachmentAsyncWithHttpInfo($attachment_id)
    {
        $returnType = '';
        $request = $this->deleteConstituentAttachmentRequest($attachment_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteConstituentAttachment'
     *
     * @param  string $attachment_id The immutable system record ID of the attachment to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteConstituentAttachmentRequest($attachment_id)
    {
        // verify the required parameter 'attachment_id' is set
        if ($attachment_id === null || (is_array($attachment_id) && count($attachment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachment_id when calling deleteConstituentAttachment'
            );
        }

        $resourcePath = '/constituents/attachments/{attachment_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($attachment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attachment_id' . '}',
                ObjectSerializer::toPathValue($attachment_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteConstituentCode
     *
     * Constituent code (Delete)
     *
     * @param  string $constituent_code_id The immutable system record ID of the constituent code to delete. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteConstituentCode($constituent_code_id)
    {
        $this->deleteConstituentCodeWithHttpInfo($constituent_code_id);
    }

    /**
     * Operation deleteConstituentCodeWithHttpInfo
     *
     * Constituent code (Delete)
     *
     * @param  string $constituent_code_id The immutable system record ID of the constituent code to delete. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteConstituentCodeWithHttpInfo($constituent_code_id)
    {
        $returnType = '';
        $request = $this->deleteConstituentCodeRequest($constituent_code_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteConstituentCodeAsync
     *
     * Constituent code (Delete)
     *
     * @param  string $constituent_code_id The immutable system record ID of the constituent code to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteConstituentCodeAsync($constituent_code_id)
    {
        return $this->deleteConstituentCodeAsyncWithHttpInfo($constituent_code_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteConstituentCodeAsyncWithHttpInfo
     *
     * Constituent code (Delete)
     *
     * @param  string $constituent_code_id The immutable system record ID of the constituent code to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteConstituentCodeAsyncWithHttpInfo($constituent_code_id)
    {
        $returnType = '';
        $request = $this->deleteConstituentCodeRequest($constituent_code_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteConstituentCode'
     *
     * @param  string $constituent_code_id The immutable system record ID of the constituent code to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteConstituentCodeRequest($constituent_code_id)
    {
        // verify the required parameter 'constituent_code_id' is set
        if ($constituent_code_id === null || (is_array($constituent_code_id) && count($constituent_code_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $constituent_code_id when calling deleteConstituentCode'
            );
        }

        $resourcePath = '/constituentcodes/{constituent_code_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($constituent_code_id !== null) {
            $resourcePath = str_replace(
                '{' . 'constituent_code_id' . '}',
                ObjectSerializer::toPathValue($constituent_code_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteConstituentCustomField
     *
     * Constituent custom field (Delete)
     *
     * @param  string $custom_field_id The immutable system record ID of the custom field to delete. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteConstituentCustomField($custom_field_id)
    {
        $this->deleteConstituentCustomFieldWithHttpInfo($custom_field_id);
    }

    /**
     * Operation deleteConstituentCustomFieldWithHttpInfo
     *
     * Constituent custom field (Delete)
     *
     * @param  string $custom_field_id The immutable system record ID of the custom field to delete. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteConstituentCustomFieldWithHttpInfo($custom_field_id)
    {
        $returnType = '';
        $request = $this->deleteConstituentCustomFieldRequest($custom_field_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteConstituentCustomFieldAsync
     *
     * Constituent custom field (Delete)
     *
     * @param  string $custom_field_id The immutable system record ID of the custom field to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteConstituentCustomFieldAsync($custom_field_id)
    {
        return $this->deleteConstituentCustomFieldAsyncWithHttpInfo($custom_field_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteConstituentCustomFieldAsyncWithHttpInfo
     *
     * Constituent custom field (Delete)
     *
     * @param  string $custom_field_id The immutable system record ID of the custom field to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteConstituentCustomFieldAsyncWithHttpInfo($custom_field_id)
    {
        $returnType = '';
        $request = $this->deleteConstituentCustomFieldRequest($custom_field_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteConstituentCustomField'
     *
     * @param  string $custom_field_id The immutable system record ID of the custom field to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteConstituentCustomFieldRequest($custom_field_id)
    {
        // verify the required parameter 'custom_field_id' is set
        if ($custom_field_id === null || (is_array($custom_field_id) && count($custom_field_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custom_field_id when calling deleteConstituentCustomField'
            );
        }

        $resourcePath = '/constituents/customfields/{custom_field_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($custom_field_id !== null) {
            $resourcePath = str_replace(
                '{' . 'custom_field_id' . '}',
                ObjectSerializer::toPathValue($custom_field_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation editConstituent
     *
     * Constituent (Edit)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ConstituentEdit $body An object that represents the properties of the constituent to edit. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function editConstituent($constituent_id, $body = null)
    {
        $this->editConstituentWithHttpInfo($constituent_id, $body);
    }

    /**
     * Operation editConstituentWithHttpInfo
     *
     * Constituent (Edit)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ConstituentEdit $body An object that represents the properties of the constituent to edit. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function editConstituentWithHttpInfo($constituent_id, $body = null)
    {
        $returnType = '';
        $request = $this->editConstituentRequest($constituent_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation editConstituentAsync
     *
     * Constituent (Edit)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ConstituentEdit $body An object that represents the properties of the constituent to edit. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editConstituentAsync($constituent_id, $body = null)
    {
        return $this->editConstituentAsyncWithHttpInfo($constituent_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation editConstituentAsyncWithHttpInfo
     *
     * Constituent (Edit)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ConstituentEdit $body An object that represents the properties of the constituent to edit. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editConstituentAsyncWithHttpInfo($constituent_id, $body = null)
    {
        $returnType = '';
        $request = $this->editConstituentRequest($constituent_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'editConstituent'
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ConstituentEdit $body An object that represents the properties of the constituent to edit. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function editConstituentRequest($constituent_id, $body = null)
    {
        // verify the required parameter 'constituent_id' is set
        if ($constituent_id === null || (is_array($constituent_id) && count($constituent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $constituent_id when calling editConstituent'
            );
        }

        $resourcePath = '/constituents/{constituent_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($constituent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'constituent_id' . '}',
                ObjectSerializer::toPathValue($constituent_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation editConstituentAttachment
     *
     * Constituent attachment (Edit)
     *
     * @param  string $attachment_id The immutable system record ID of the attachment to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\AttachmentEdit $body An object that represents the properties of the attachment to edit. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function editConstituentAttachment($attachment_id, $body = null)
    {
        $this->editConstituentAttachmentWithHttpInfo($attachment_id, $body);
    }

    /**
     * Operation editConstituentAttachmentWithHttpInfo
     *
     * Constituent attachment (Edit)
     *
     * @param  string $attachment_id The immutable system record ID of the attachment to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\AttachmentEdit $body An object that represents the properties of the attachment to edit. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function editConstituentAttachmentWithHttpInfo($attachment_id, $body = null)
    {
        $returnType = '';
        $request = $this->editConstituentAttachmentRequest($attachment_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation editConstituentAttachmentAsync
     *
     * Constituent attachment (Edit)
     *
     * @param  string $attachment_id The immutable system record ID of the attachment to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\AttachmentEdit $body An object that represents the properties of the attachment to edit. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editConstituentAttachmentAsync($attachment_id, $body = null)
    {
        return $this->editConstituentAttachmentAsyncWithHttpInfo($attachment_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation editConstituentAttachmentAsyncWithHttpInfo
     *
     * Constituent attachment (Edit)
     *
     * @param  string $attachment_id The immutable system record ID of the attachment to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\AttachmentEdit $body An object that represents the properties of the attachment to edit. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editConstituentAttachmentAsyncWithHttpInfo($attachment_id, $body = null)
    {
        $returnType = '';
        $request = $this->editConstituentAttachmentRequest($attachment_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'editConstituentAttachment'
     *
     * @param  string $attachment_id The immutable system record ID of the attachment to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\AttachmentEdit $body An object that represents the properties of the attachment to edit. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function editConstituentAttachmentRequest($attachment_id, $body = null)
    {
        // verify the required parameter 'attachment_id' is set
        if ($attachment_id === null || (is_array($attachment_id) && count($attachment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachment_id when calling editConstituentAttachment'
            );
        }

        $resourcePath = '/constituents/attachments/{attachment_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($attachment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attachment_id' . '}',
                ObjectSerializer::toPathValue($attachment_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation editConstituentCode
     *
     * Constituent code (Edit)
     *
     * @param  string $constituent_code_id The immutable system record ID of the constituent code to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ConstituentCodeEdit $body An object that represents the properties of the constituent code to edit. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function editConstituentCode($constituent_code_id, $body = null)
    {
        $this->editConstituentCodeWithHttpInfo($constituent_code_id, $body);
    }

    /**
     * Operation editConstituentCodeWithHttpInfo
     *
     * Constituent code (Edit)
     *
     * @param  string $constituent_code_id The immutable system record ID of the constituent code to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ConstituentCodeEdit $body An object that represents the properties of the constituent code to edit. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function editConstituentCodeWithHttpInfo($constituent_code_id, $body = null)
    {
        $returnType = '';
        $request = $this->editConstituentCodeRequest($constituent_code_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation editConstituentCodeAsync
     *
     * Constituent code (Edit)
     *
     * @param  string $constituent_code_id The immutable system record ID of the constituent code to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ConstituentCodeEdit $body An object that represents the properties of the constituent code to edit. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editConstituentCodeAsync($constituent_code_id, $body = null)
    {
        return $this->editConstituentCodeAsyncWithHttpInfo($constituent_code_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation editConstituentCodeAsyncWithHttpInfo
     *
     * Constituent code (Edit)
     *
     * @param  string $constituent_code_id The immutable system record ID of the constituent code to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ConstituentCodeEdit $body An object that represents the properties of the constituent code to edit. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editConstituentCodeAsyncWithHttpInfo($constituent_code_id, $body = null)
    {
        $returnType = '';
        $request = $this->editConstituentCodeRequest($constituent_code_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'editConstituentCode'
     *
     * @param  string $constituent_code_id The immutable system record ID of the constituent code to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ConstituentCodeEdit $body An object that represents the properties of the constituent code to edit. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function editConstituentCodeRequest($constituent_code_id, $body = null)
    {
        // verify the required parameter 'constituent_code_id' is set
        if ($constituent_code_id === null || (is_array($constituent_code_id) && count($constituent_code_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $constituent_code_id when calling editConstituentCode'
            );
        }

        $resourcePath = '/constituentcodes/{constituent_code_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($constituent_code_id !== null) {
            $resourcePath = str_replace(
                '{' . 'constituent_code_id' . '}',
                ObjectSerializer::toPathValue($constituent_code_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation editConstituentCustomField
     *
     * Constituent custom field (Edit)
     *
     * @param  string $custom_field_id The immutable system record ID of the custom field to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\CustomFieldEdit $body An object that represents the properties of the custom field to edit. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function editConstituentCustomField($custom_field_id, $body = null)
    {
        $this->editConstituentCustomFieldWithHttpInfo($custom_field_id, $body);
    }

    /**
     * Operation editConstituentCustomFieldWithHttpInfo
     *
     * Constituent custom field (Edit)
     *
     * @param  string $custom_field_id The immutable system record ID of the custom field to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\CustomFieldEdit $body An object that represents the properties of the custom field to edit. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function editConstituentCustomFieldWithHttpInfo($custom_field_id, $body = null)
    {
        $returnType = '';
        $request = $this->editConstituentCustomFieldRequest($custom_field_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation editConstituentCustomFieldAsync
     *
     * Constituent custom field (Edit)
     *
     * @param  string $custom_field_id The immutable system record ID of the custom field to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\CustomFieldEdit $body An object that represents the properties of the custom field to edit. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editConstituentCustomFieldAsync($custom_field_id, $body = null)
    {
        return $this->editConstituentCustomFieldAsyncWithHttpInfo($custom_field_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation editConstituentCustomFieldAsyncWithHttpInfo
     *
     * Constituent custom field (Edit)
     *
     * @param  string $custom_field_id The immutable system record ID of the custom field to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\CustomFieldEdit $body An object that represents the properties of the custom field to edit. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editConstituentCustomFieldAsyncWithHttpInfo($custom_field_id, $body = null)
    {
        $returnType = '';
        $request = $this->editConstituentCustomFieldRequest($custom_field_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'editConstituentCustomField'
     *
     * @param  string $custom_field_id The immutable system record ID of the custom field to edit. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\CustomFieldEdit $body An object that represents the properties of the custom field to edit. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function editConstituentCustomFieldRequest($custom_field_id, $body = null)
    {
        // verify the required parameter 'custom_field_id' is set
        if ($custom_field_id === null || (is_array($custom_field_id) && count($custom_field_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custom_field_id when calling editConstituentCustomField'
            );
        }

        $resourcePath = '/constituents/customfields/{custom_field_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($custom_field_id !== null) {
            $resourcePath = str_replace(
                '{' . 'custom_field_id' . '}',
                ObjectSerializer::toPathValue($custom_field_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConstituent
     *
     * Constituent (Get)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent for whom information is to be retrieved. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ConstituentRead
     */
    public function getConstituent($constituent_id)
    {
        list($response) = $this->getConstituentWithHttpInfo($constituent_id);
        return $response;
    }

    /**
     * Operation getConstituentWithHttpInfo
     *
     * Constituent (Get)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent for whom information is to be retrieved. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ConstituentRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConstituentWithHttpInfo($constituent_id)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ConstituentRead';
        $request = $this->getConstituentRequest($constituent_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ConstituentRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConstituentAsync
     *
     * Constituent (Get)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent for whom information is to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConstituentAsync($constituent_id)
    {
        return $this->getConstituentAsyncWithHttpInfo($constituent_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConstituentAsyncWithHttpInfo
     *
     * Constituent (Get)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent for whom information is to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConstituentAsyncWithHttpInfo($constituent_id)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ConstituentRead';
        $request = $this->getConstituentRequest($constituent_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConstituent'
     *
     * @param  string $constituent_id The immutable system record ID of the constituent for whom information is to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getConstituentRequest($constituent_id)
    {
        // verify the required parameter 'constituent_id' is set
        if ($constituent_id === null || (is_array($constituent_id) && count($constituent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $constituent_id when calling getConstituent'
            );
        }

        $resourcePath = '/constituents/{constituent_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($constituent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'constituent_id' . '}',
                ObjectSerializer::toPathValue($constituent_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConstituentCode
     *
     * Constituent code (Get)
     *
     * @param  string $constituent_code_id The immutable system record ID of the constituent code to retrieve. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ConstituentCodeRead
     */
    public function getConstituentCode($constituent_code_id)
    {
        list($response) = $this->getConstituentCodeWithHttpInfo($constituent_code_id);
        return $response;
    }

    /**
     * Operation getConstituentCodeWithHttpInfo
     *
     * Constituent code (Get)
     *
     * @param  string $constituent_code_id The immutable system record ID of the constituent code to retrieve. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ConstituentCodeRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConstituentCodeWithHttpInfo($constituent_code_id)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ConstituentCodeRead';
        $request = $this->getConstituentCodeRequest($constituent_code_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ConstituentCodeRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConstituentCodeAsync
     *
     * Constituent code (Get)
     *
     * @param  string $constituent_code_id The immutable system record ID of the constituent code to retrieve. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConstituentCodeAsync($constituent_code_id)
    {
        return $this->getConstituentCodeAsyncWithHttpInfo($constituent_code_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConstituentCodeAsyncWithHttpInfo
     *
     * Constituent code (Get)
     *
     * @param  string $constituent_code_id The immutable system record ID of the constituent code to retrieve. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConstituentCodeAsyncWithHttpInfo($constituent_code_id)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ConstituentCodeRead';
        $request = $this->getConstituentCodeRequest($constituent_code_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConstituentCode'
     *
     * @param  string $constituent_code_id The immutable system record ID of the constituent code to retrieve. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getConstituentCodeRequest($constituent_code_id)
    {
        // verify the required parameter 'constituent_code_id' is set
        if ($constituent_code_id === null || (is_array($constituent_code_id) && count($constituent_code_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $constituent_code_id when calling getConstituentCode'
            );
        }

        $resourcePath = '/constituents/constituentcodes/{constituent_code_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($constituent_code_id !== null) {
            $resourcePath = str_replace(
                '{' . 'constituent_code_id' . '}',
                ObjectSerializer::toPathValue($constituent_code_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConstituentProfilePicture
     *
     * Profile picture (Get)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the current profile picture for. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ProfilePictureRead
     */
    public function getConstituentProfilePicture($constituent_id)
    {
        list($response) = $this->getConstituentProfilePictureWithHttpInfo($constituent_id);
        return $response;
    }

    /**
     * Operation getConstituentProfilePictureWithHttpInfo
     *
     * Profile picture (Get)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the current profile picture for. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ProfilePictureRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConstituentProfilePictureWithHttpInfo($constituent_id)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ProfilePictureRead';
        $request = $this->getConstituentProfilePictureRequest($constituent_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ProfilePictureRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConstituentProfilePictureAsync
     *
     * Profile picture (Get)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the current profile picture for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConstituentProfilePictureAsync($constituent_id)
    {
        return $this->getConstituentProfilePictureAsyncWithHttpInfo($constituent_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConstituentProfilePictureAsyncWithHttpInfo
     *
     * Profile picture (Get)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the current profile picture for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConstituentProfilePictureAsyncWithHttpInfo($constituent_id)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ProfilePictureRead';
        $request = $this->getConstituentProfilePictureRequest($constituent_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConstituentProfilePicture'
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the current profile picture for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getConstituentProfilePictureRequest($constituent_id)
    {
        // verify the required parameter 'constituent_id' is set
        if ($constituent_id === null || (is_array($constituent_id) && count($constituent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $constituent_id when calling getConstituentProfilePicture'
            );
        }

        $resourcePath = '/constituents/{constituent_id}/profilepicture';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($constituent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'constituent_id' . '}',
                ObjectSerializer::toPathValue($constituent_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCurrencyConfiguration
     *
     * Currency configuration (Get)
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\CurrencyConfigurationRead
     */
    public function getCurrencyConfiguration()
    {
        list($response) = $this->getCurrencyConfigurationWithHttpInfo();
        return $response;
    }

    /**
     * Operation getCurrencyConfigurationWithHttpInfo
     *
     * Currency configuration (Get)
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\CurrencyConfigurationRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCurrencyConfigurationWithHttpInfo()
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\CurrencyConfigurationRead';
        $request = $this->getCurrencyConfigurationRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\CurrencyConfigurationRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCurrencyConfigurationAsync
     *
     * Currency configuration (Get)
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrencyConfigurationAsync()
    {
        return $this->getCurrencyConfigurationAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCurrencyConfigurationAsyncWithHttpInfo
     *
     * Currency configuration (Get)
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrencyConfigurationAsyncWithHttpInfo()
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\CurrencyConfigurationRead';
        $request = $this->getCurrencyConfigurationRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCurrencyConfiguration'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCurrencyConfigurationRequest()
    {

        $resourcePath = '/currencyconfiguration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listAttachmentTags
     *
     * Attachment tags
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString
     */
    public function listAttachmentTags()
    {
        list($response) = $this->listAttachmentTagsWithHttpInfo();
        return $response;
    }

    /**
     * Operation listAttachmentTagsWithHttpInfo
     *
     * Attachment tags
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString, HTTP status code, HTTP response headers (array of strings)
     */
    public function listAttachmentTagsWithHttpInfo()
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString';
        $request = $this->listAttachmentTagsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listAttachmentTagsAsync
     *
     * Attachment tags
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAttachmentTagsAsync()
    {
        return $this->listAttachmentTagsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listAttachmentTagsAsyncWithHttpInfo
     *
     * Attachment tags
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAttachmentTagsAsyncWithHttpInfo()
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString';
        $request = $this->listAttachmentTagsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listAttachmentTags'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listAttachmentTagsRequest()
    {

        $resourcePath = '/attachmenttags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listConstituentAttachmentsSingleConstituent
     *
     * Constituent attachment list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the attachments for. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionAttachmentRead
     */
    public function listConstituentAttachmentsSingleConstituent($constituent_id)
    {
        list($response) = $this->listConstituentAttachmentsSingleConstituentWithHttpInfo($constituent_id);
        return $response;
    }

    /**
     * Operation listConstituentAttachmentsSingleConstituentWithHttpInfo
     *
     * Constituent attachment list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the attachments for. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionAttachmentRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConstituentAttachmentsSingleConstituentWithHttpInfo($constituent_id)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionAttachmentRead';
        $request = $this->listConstituentAttachmentsSingleConstituentRequest($constituent_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionAttachmentRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConstituentAttachmentsSingleConstituentAsync
     *
     * Constituent attachment list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the attachments for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentAttachmentsSingleConstituentAsync($constituent_id)
    {
        return $this->listConstituentAttachmentsSingleConstituentAsyncWithHttpInfo($constituent_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConstituentAttachmentsSingleConstituentAsyncWithHttpInfo
     *
     * Constituent attachment list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the attachments for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentAttachmentsSingleConstituentAsyncWithHttpInfo($constituent_id)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionAttachmentRead';
        $request = $this->listConstituentAttachmentsSingleConstituentRequest($constituent_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listConstituentAttachmentsSingleConstituent'
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the attachments for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listConstituentAttachmentsSingleConstituentRequest($constituent_id)
    {
        // verify the required parameter 'constituent_id' is set
        if ($constituent_id === null || (is_array($constituent_id) && count($constituent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $constituent_id when calling listConstituentAttachmentsSingleConstituent'
            );
        }

        $resourcePath = '/constituents/{constituent_id}/attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($constituent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'constituent_id' . '}',
                ObjectSerializer::toPathValue($constituent_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listConstituentCodeTypes
     *
     * Constituent code types
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString
     */
    public function listConstituentCodeTypes()
    {
        list($response) = $this->listConstituentCodeTypesWithHttpInfo();
        return $response;
    }

    /**
     * Operation listConstituentCodeTypesWithHttpInfo
     *
     * Constituent code types
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConstituentCodeTypesWithHttpInfo()
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString';
        $request = $this->listConstituentCodeTypesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConstituentCodeTypesAsync
     *
     * Constituent code types
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentCodeTypesAsync()
    {
        return $this->listConstituentCodeTypesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConstituentCodeTypesAsyncWithHttpInfo
     *
     * Constituent code types
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentCodeTypesAsyncWithHttpInfo()
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString';
        $request = $this->listConstituentCodeTypesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listConstituentCodeTypes'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listConstituentCodeTypesRequest()
    {

        $resourcePath = '/constituentcodetypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listConstituentCodesAllConstituents
     *
     * Constituent code list (All constituents)
     *
     * @param  bool $include_inactive Set this parameter to \&quot;true\&quot; to include inactive constituent codes in the response. (optional)
     * @param  string $date_added Format - date-time (as date-time in RFC3339). Represents a filter for constituent codes created on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $last_modified Format - date-time (as date-time in RFC3339). Represents a filter for constituent codes modified on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $sort_token Represents a token filter to provide the next stable-sorted list of constituent codes. This will be provided on the next_link collection response property when last_modified or sort_token filters are specified on the request. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionConstituentCodeRead
     */
    public function listConstituentCodesAllConstituents($include_inactive = null, $date_added = null, $last_modified = null, $sort_token = null, $limit = null, $offset = null)
    {
        list($response) = $this->listConstituentCodesAllConstituentsWithHttpInfo($include_inactive, $date_added, $last_modified, $sort_token, $limit, $offset);
        return $response;
    }

    /**
     * Operation listConstituentCodesAllConstituentsWithHttpInfo
     *
     * Constituent code list (All constituents)
     *
     * @param  bool $include_inactive Set this parameter to \&quot;true\&quot; to include inactive constituent codes in the response. (optional)
     * @param  string $date_added Format - date-time (as date-time in RFC3339). Represents a filter for constituent codes created on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $last_modified Format - date-time (as date-time in RFC3339). Represents a filter for constituent codes modified on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $sort_token Represents a token filter to provide the next stable-sorted list of constituent codes. This will be provided on the next_link collection response property when last_modified or sort_token filters are specified on the request. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionConstituentCodeRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConstituentCodesAllConstituentsWithHttpInfo($include_inactive = null, $date_added = null, $last_modified = null, $sort_token = null, $limit = null, $offset = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionConstituentCodeRead';
        $request = $this->listConstituentCodesAllConstituentsRequest($include_inactive, $date_added, $last_modified, $sort_token, $limit, $offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionConstituentCodeRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConstituentCodesAllConstituentsAsync
     *
     * Constituent code list (All constituents)
     *
     * @param  bool $include_inactive Set this parameter to \&quot;true\&quot; to include inactive constituent codes in the response. (optional)
     * @param  string $date_added Format - date-time (as date-time in RFC3339). Represents a filter for constituent codes created on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $last_modified Format - date-time (as date-time in RFC3339). Represents a filter for constituent codes modified on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $sort_token Represents a token filter to provide the next stable-sorted list of constituent codes. This will be provided on the next_link collection response property when last_modified or sort_token filters are specified on the request. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentCodesAllConstituentsAsync($include_inactive = null, $date_added = null, $last_modified = null, $sort_token = null, $limit = null, $offset = null)
    {
        return $this->listConstituentCodesAllConstituentsAsyncWithHttpInfo($include_inactive, $date_added, $last_modified, $sort_token, $limit, $offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConstituentCodesAllConstituentsAsyncWithHttpInfo
     *
     * Constituent code list (All constituents)
     *
     * @param  bool $include_inactive Set this parameter to \&quot;true\&quot; to include inactive constituent codes in the response. (optional)
     * @param  string $date_added Format - date-time (as date-time in RFC3339). Represents a filter for constituent codes created on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $last_modified Format - date-time (as date-time in RFC3339). Represents a filter for constituent codes modified on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $sort_token Represents a token filter to provide the next stable-sorted list of constituent codes. This will be provided on the next_link collection response property when last_modified or sort_token filters are specified on the request. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentCodesAllConstituentsAsyncWithHttpInfo($include_inactive = null, $date_added = null, $last_modified = null, $sort_token = null, $limit = null, $offset = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionConstituentCodeRead';
        $request = $this->listConstituentCodesAllConstituentsRequest($include_inactive, $date_added, $last_modified, $sort_token, $limit, $offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listConstituentCodesAllConstituents'
     *
     * @param  bool $include_inactive Set this parameter to \&quot;true\&quot; to include inactive constituent codes in the response. (optional)
     * @param  string $date_added Format - date-time (as date-time in RFC3339). Represents a filter for constituent codes created on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $last_modified Format - date-time (as date-time in RFC3339). Represents a filter for constituent codes modified on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $sort_token Represents a token filter to provide the next stable-sorted list of constituent codes. This will be provided on the next_link collection response property when last_modified or sort_token filters are specified on the request. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listConstituentCodesAllConstituentsRequest($include_inactive = null, $date_added = null, $last_modified = null, $sort_token = null, $limit = null, $offset = null)
    {

        $resourcePath = '/constituents/constituentcodes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_inactive !== null) {
            $queryParams['include_inactive'] = ObjectSerializer::toQueryValue($include_inactive, null);
        }
        // query params
        if ($date_added !== null) {
            $queryParams['date_added'] = ObjectSerializer::toQueryValue($date_added, null);
        }
        // query params
        if ($last_modified !== null) {
            $queryParams['last_modified'] = ObjectSerializer::toQueryValue($last_modified, null);
        }
        // query params
        if ($sort_token !== null) {
            $queryParams['sort_token'] = ObjectSerializer::toQueryValue($sort_token, null);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listConstituentCodesSingleConstituent
     *
     * Constituent code list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the constituent codes for. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionConstituentCodeRead
     */
    public function listConstituentCodesSingleConstituent($constituent_id)
    {
        list($response) = $this->listConstituentCodesSingleConstituentWithHttpInfo($constituent_id);
        return $response;
    }

    /**
     * Operation listConstituentCodesSingleConstituentWithHttpInfo
     *
     * Constituent code list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the constituent codes for. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionConstituentCodeRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConstituentCodesSingleConstituentWithHttpInfo($constituent_id)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionConstituentCodeRead';
        $request = $this->listConstituentCodesSingleConstituentRequest($constituent_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionConstituentCodeRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConstituentCodesSingleConstituentAsync
     *
     * Constituent code list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the constituent codes for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentCodesSingleConstituentAsync($constituent_id)
    {
        return $this->listConstituentCodesSingleConstituentAsyncWithHttpInfo($constituent_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConstituentCodesSingleConstituentAsyncWithHttpInfo
     *
     * Constituent code list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the constituent codes for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentCodesSingleConstituentAsyncWithHttpInfo($constituent_id)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionConstituentCodeRead';
        $request = $this->listConstituentCodesSingleConstituentRequest($constituent_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listConstituentCodesSingleConstituent'
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the constituent codes for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listConstituentCodesSingleConstituentRequest($constituent_id)
    {
        // verify the required parameter 'constituent_id' is set
        if ($constituent_id === null || (is_array($constituent_id) && count($constituent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $constituent_id when calling listConstituentCodesSingleConstituent'
            );
        }

        $resourcePath = '/constituents/{constituent_id}/constituentcodes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($constituent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'constituent_id' . '}',
                ObjectSerializer::toPathValue($constituent_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listConstituentCustomFieldCategories
     *
     * Constituent custom field categories
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString
     */
    public function listConstituentCustomFieldCategories()
    {
        list($response) = $this->listConstituentCustomFieldCategoriesWithHttpInfo();
        return $response;
    }

    /**
     * Operation listConstituentCustomFieldCategoriesWithHttpInfo
     *
     * Constituent custom field categories
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConstituentCustomFieldCategoriesWithHttpInfo()
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString';
        $request = $this->listConstituentCustomFieldCategoriesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConstituentCustomFieldCategoriesAsync
     *
     * Constituent custom field categories
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentCustomFieldCategoriesAsync()
    {
        return $this->listConstituentCustomFieldCategoriesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConstituentCustomFieldCategoriesAsyncWithHttpInfo
     *
     * Constituent custom field categories
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentCustomFieldCategoriesAsyncWithHttpInfo()
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString';
        $request = $this->listConstituentCustomFieldCategoriesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listConstituentCustomFieldCategories'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listConstituentCustomFieldCategoriesRequest()
    {

        $resourcePath = '/constituents/customfields/categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listConstituentCustomFieldCategoryDetails
     *
     * Constituent custom field category details
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionCustomFieldCategoryRead
     */
    public function listConstituentCustomFieldCategoryDetails()
    {
        list($response) = $this->listConstituentCustomFieldCategoryDetailsWithHttpInfo();
        return $response;
    }

    /**
     * Operation listConstituentCustomFieldCategoryDetailsWithHttpInfo
     *
     * Constituent custom field category details
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionCustomFieldCategoryRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConstituentCustomFieldCategoryDetailsWithHttpInfo()
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionCustomFieldCategoryRead';
        $request = $this->listConstituentCustomFieldCategoryDetailsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionCustomFieldCategoryRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConstituentCustomFieldCategoryDetailsAsync
     *
     * Constituent custom field category details
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentCustomFieldCategoryDetailsAsync()
    {
        return $this->listConstituentCustomFieldCategoryDetailsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConstituentCustomFieldCategoryDetailsAsyncWithHttpInfo
     *
     * Constituent custom field category details
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentCustomFieldCategoryDetailsAsyncWithHttpInfo()
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionCustomFieldCategoryRead';
        $request = $this->listConstituentCustomFieldCategoryDetailsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listConstituentCustomFieldCategoryDetails'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listConstituentCustomFieldCategoryDetailsRequest()
    {

        $resourcePath = '/constituents/customfields/categories/details';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listConstituentCustomFieldCategoryValues
     *
     * Constituent custom field category values
     *
     * @param  string $category_name The name of the category to return values for. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString
     */
    public function listConstituentCustomFieldCategoryValues($category_name = null)
    {
        list($response) = $this->listConstituentCustomFieldCategoryValuesWithHttpInfo($category_name);
        return $response;
    }

    /**
     * Operation listConstituentCustomFieldCategoryValuesWithHttpInfo
     *
     * Constituent custom field category values
     *
     * @param  string $category_name The name of the category to return values for. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConstituentCustomFieldCategoryValuesWithHttpInfo($category_name = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString';
        $request = $this->listConstituentCustomFieldCategoryValuesRequest($category_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConstituentCustomFieldCategoryValuesAsync
     *
     * Constituent custom field category values
     *
     * @param  string $category_name The name of the category to return values for. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentCustomFieldCategoryValuesAsync($category_name = null)
    {
        return $this->listConstituentCustomFieldCategoryValuesAsyncWithHttpInfo($category_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConstituentCustomFieldCategoryValuesAsyncWithHttpInfo
     *
     * Constituent custom field category values
     *
     * @param  string $category_name The name of the category to return values for. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentCustomFieldCategoryValuesAsyncWithHttpInfo($category_name = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString';
        $request = $this->listConstituentCustomFieldCategoryValuesRequest($category_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listConstituentCustomFieldCategoryValues'
     *
     * @param  string $category_name The name of the category to return values for. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listConstituentCustomFieldCategoryValuesRequest($category_name = null)
    {

        $resourcePath = '/constituents/customfields/categories/values';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category_name !== null) {
            $queryParams['category_name'] = ObjectSerializer::toQueryValue($category_name, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listConstituentCustomFieldsAllConstituents
     *
     * Constituent custom field list (All constituents)
     *
     * @param  string $date_added Format - date-time (as date-time in RFC3339). Represents a filter for constituent custom fields created on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $last_modified Format - date-time (as date-time in RFC3339). Represents a filter for constituent custom fields modified on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $sort_token Represents a token filter to provide the next stable-sorted list of constituent custom fields. This will be provided on the next_link collection response property when last_modified or sort_token filters are specified on the request. (optional)
     * @param  string $category Represents a filter for custom field categories. Returns any custom fields that match the specified category. For example, &lt;i&gt;category&#x3D;Interests&lt;/i&gt; returns custom fields with the &lt;i&gt;Interests&lt;/i&gt; category. (optional)
     * @param  string $value Represents a filter for custom field values. Must be used in conjunction with the &lt;code&gt;category&lt;/code&gt; filter. Returns any custom fields in the specified category that match any of the specified values. For example, &lt;i&gt;category&#x3D;Interests&amp;amp;value&#x3D;Baseball&amp;amp;value&#x3D;Tennis&lt;/i&gt; returns &lt;i&gt;Interests&lt;/i&gt; custom fields with the &lt;i&gt;Baseball&lt;/i&gt; or &lt;i&gt;Tennis&lt;/i&gt; values. Filtering by fuzzy date values must be in one of the following formats: &lt;i&gt;YYYYMMDD&lt;/i&gt;, &lt;i&gt;YYYY&lt;/i&gt;, &lt;i&gt;YYYYMM&lt;/i&gt;, or &lt;i&gt;MMDD&lt;/i&gt;.  Any four digit value that starts with 13 or higher will be considered a year.  Any four digit value that starts with 01-12 will be considered to be in &lt;i&gt;MMDD&lt;/i&gt; format. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionCustomFieldRead
     */
    public function listConstituentCustomFieldsAllConstituents($date_added = null, $last_modified = null, $sort_token = null, $category = null, $value = null, $limit = null, $offset = null)
    {
        list($response) = $this->listConstituentCustomFieldsAllConstituentsWithHttpInfo($date_added, $last_modified, $sort_token, $category, $value, $limit, $offset);
        return $response;
    }

    /**
     * Operation listConstituentCustomFieldsAllConstituentsWithHttpInfo
     *
     * Constituent custom field list (All constituents)
     *
     * @param  string $date_added Format - date-time (as date-time in RFC3339). Represents a filter for constituent custom fields created on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $last_modified Format - date-time (as date-time in RFC3339). Represents a filter for constituent custom fields modified on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $sort_token Represents a token filter to provide the next stable-sorted list of constituent custom fields. This will be provided on the next_link collection response property when last_modified or sort_token filters are specified on the request. (optional)
     * @param  string $category Represents a filter for custom field categories. Returns any custom fields that match the specified category. For example, &lt;i&gt;category&#x3D;Interests&lt;/i&gt; returns custom fields with the &lt;i&gt;Interests&lt;/i&gt; category. (optional)
     * @param  string $value Represents a filter for custom field values. Must be used in conjunction with the &lt;code&gt;category&lt;/code&gt; filter. Returns any custom fields in the specified category that match any of the specified values. For example, &lt;i&gt;category&#x3D;Interests&amp;amp;value&#x3D;Baseball&amp;amp;value&#x3D;Tennis&lt;/i&gt; returns &lt;i&gt;Interests&lt;/i&gt; custom fields with the &lt;i&gt;Baseball&lt;/i&gt; or &lt;i&gt;Tennis&lt;/i&gt; values. Filtering by fuzzy date values must be in one of the following formats: &lt;i&gt;YYYYMMDD&lt;/i&gt;, &lt;i&gt;YYYY&lt;/i&gt;, &lt;i&gt;YYYYMM&lt;/i&gt;, or &lt;i&gt;MMDD&lt;/i&gt;.  Any four digit value that starts with 13 or higher will be considered a year.  Any four digit value that starts with 01-12 will be considered to be in &lt;i&gt;MMDD&lt;/i&gt; format. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionCustomFieldRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConstituentCustomFieldsAllConstituentsWithHttpInfo($date_added = null, $last_modified = null, $sort_token = null, $category = null, $value = null, $limit = null, $offset = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionCustomFieldRead';
        $request = $this->listConstituentCustomFieldsAllConstituentsRequest($date_added, $last_modified, $sort_token, $category, $value, $limit, $offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionCustomFieldRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConstituentCustomFieldsAllConstituentsAsync
     *
     * Constituent custom field list (All constituents)
     *
     * @param  string $date_added Format - date-time (as date-time in RFC3339). Represents a filter for constituent custom fields created on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $last_modified Format - date-time (as date-time in RFC3339). Represents a filter for constituent custom fields modified on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $sort_token Represents a token filter to provide the next stable-sorted list of constituent custom fields. This will be provided on the next_link collection response property when last_modified or sort_token filters are specified on the request. (optional)
     * @param  string $category Represents a filter for custom field categories. Returns any custom fields that match the specified category. For example, &lt;i&gt;category&#x3D;Interests&lt;/i&gt; returns custom fields with the &lt;i&gt;Interests&lt;/i&gt; category. (optional)
     * @param  string $value Represents a filter for custom field values. Must be used in conjunction with the &lt;code&gt;category&lt;/code&gt; filter. Returns any custom fields in the specified category that match any of the specified values. For example, &lt;i&gt;category&#x3D;Interests&amp;amp;value&#x3D;Baseball&amp;amp;value&#x3D;Tennis&lt;/i&gt; returns &lt;i&gt;Interests&lt;/i&gt; custom fields with the &lt;i&gt;Baseball&lt;/i&gt; or &lt;i&gt;Tennis&lt;/i&gt; values. Filtering by fuzzy date values must be in one of the following formats: &lt;i&gt;YYYYMMDD&lt;/i&gt;, &lt;i&gt;YYYY&lt;/i&gt;, &lt;i&gt;YYYYMM&lt;/i&gt;, or &lt;i&gt;MMDD&lt;/i&gt;.  Any four digit value that starts with 13 or higher will be considered a year.  Any four digit value that starts with 01-12 will be considered to be in &lt;i&gt;MMDD&lt;/i&gt; format. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentCustomFieldsAllConstituentsAsync($date_added = null, $last_modified = null, $sort_token = null, $category = null, $value = null, $limit = null, $offset = null)
    {
        return $this->listConstituentCustomFieldsAllConstituentsAsyncWithHttpInfo($date_added, $last_modified, $sort_token, $category, $value, $limit, $offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConstituentCustomFieldsAllConstituentsAsyncWithHttpInfo
     *
     * Constituent custom field list (All constituents)
     *
     * @param  string $date_added Format - date-time (as date-time in RFC3339). Represents a filter for constituent custom fields created on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $last_modified Format - date-time (as date-time in RFC3339). Represents a filter for constituent custom fields modified on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $sort_token Represents a token filter to provide the next stable-sorted list of constituent custom fields. This will be provided on the next_link collection response property when last_modified or sort_token filters are specified on the request. (optional)
     * @param  string $category Represents a filter for custom field categories. Returns any custom fields that match the specified category. For example, &lt;i&gt;category&#x3D;Interests&lt;/i&gt; returns custom fields with the &lt;i&gt;Interests&lt;/i&gt; category. (optional)
     * @param  string $value Represents a filter for custom field values. Must be used in conjunction with the &lt;code&gt;category&lt;/code&gt; filter. Returns any custom fields in the specified category that match any of the specified values. For example, &lt;i&gt;category&#x3D;Interests&amp;amp;value&#x3D;Baseball&amp;amp;value&#x3D;Tennis&lt;/i&gt; returns &lt;i&gt;Interests&lt;/i&gt; custom fields with the &lt;i&gt;Baseball&lt;/i&gt; or &lt;i&gt;Tennis&lt;/i&gt; values. Filtering by fuzzy date values must be in one of the following formats: &lt;i&gt;YYYYMMDD&lt;/i&gt;, &lt;i&gt;YYYY&lt;/i&gt;, &lt;i&gt;YYYYMM&lt;/i&gt;, or &lt;i&gt;MMDD&lt;/i&gt;.  Any four digit value that starts with 13 or higher will be considered a year.  Any four digit value that starts with 01-12 will be considered to be in &lt;i&gt;MMDD&lt;/i&gt; format. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentCustomFieldsAllConstituentsAsyncWithHttpInfo($date_added = null, $last_modified = null, $sort_token = null, $category = null, $value = null, $limit = null, $offset = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionCustomFieldRead';
        $request = $this->listConstituentCustomFieldsAllConstituentsRequest($date_added, $last_modified, $sort_token, $category, $value, $limit, $offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listConstituentCustomFieldsAllConstituents'
     *
     * @param  string $date_added Format - date-time (as date-time in RFC3339). Represents a filter for constituent custom fields created on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $last_modified Format - date-time (as date-time in RFC3339). Represents a filter for constituent custom fields modified on or after the specified date. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $sort_token Represents a token filter to provide the next stable-sorted list of constituent custom fields. This will be provided on the next_link collection response property when last_modified or sort_token filters are specified on the request. (optional)
     * @param  string $category Represents a filter for custom field categories. Returns any custom fields that match the specified category. For example, &lt;i&gt;category&#x3D;Interests&lt;/i&gt; returns custom fields with the &lt;i&gt;Interests&lt;/i&gt; category. (optional)
     * @param  string $value Represents a filter for custom field values. Must be used in conjunction with the &lt;code&gt;category&lt;/code&gt; filter. Returns any custom fields in the specified category that match any of the specified values. For example, &lt;i&gt;category&#x3D;Interests&amp;amp;value&#x3D;Baseball&amp;amp;value&#x3D;Tennis&lt;/i&gt; returns &lt;i&gt;Interests&lt;/i&gt; custom fields with the &lt;i&gt;Baseball&lt;/i&gt; or &lt;i&gt;Tennis&lt;/i&gt; values. Filtering by fuzzy date values must be in one of the following formats: &lt;i&gt;YYYYMMDD&lt;/i&gt;, &lt;i&gt;YYYY&lt;/i&gt;, &lt;i&gt;YYYYMM&lt;/i&gt;, or &lt;i&gt;MMDD&lt;/i&gt;.  Any four digit value that starts with 13 or higher will be considered a year.  Any four digit value that starts with 01-12 will be considered to be in &lt;i&gt;MMDD&lt;/i&gt; format. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listConstituentCustomFieldsAllConstituentsRequest($date_added = null, $last_modified = null, $sort_token = null, $category = null, $value = null, $limit = null, $offset = null)
    {

        $resourcePath = '/constituents/customfields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($date_added !== null) {
            $queryParams['date_added'] = ObjectSerializer::toQueryValue($date_added, null);
        }
        // query params
        if ($last_modified !== null) {
            $queryParams['last_modified'] = ObjectSerializer::toQueryValue($last_modified, null);
        }
        // query params
        if ($sort_token !== null) {
            $queryParams['sort_token'] = ObjectSerializer::toQueryValue($sort_token, null);
        }
        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category, null);
        }
        // query params
        if ($value !== null) {
            $queryParams['value'] = ObjectSerializer::toQueryValue($value, null);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listConstituentCustomFieldsSingleConstituent
     *
     * Constituent custom field list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the custom fields for. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionCustomFieldRead
     */
    public function listConstituentCustomFieldsSingleConstituent($constituent_id)
    {
        list($response) = $this->listConstituentCustomFieldsSingleConstituentWithHttpInfo($constituent_id);
        return $response;
    }

    /**
     * Operation listConstituentCustomFieldsSingleConstituentWithHttpInfo
     *
     * Constituent custom field list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the custom fields for. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionCustomFieldRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConstituentCustomFieldsSingleConstituentWithHttpInfo($constituent_id)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionCustomFieldRead';
        $request = $this->listConstituentCustomFieldsSingleConstituentRequest($constituent_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionCustomFieldRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConstituentCustomFieldsSingleConstituentAsync
     *
     * Constituent custom field list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the custom fields for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentCustomFieldsSingleConstituentAsync($constituent_id)
    {
        return $this->listConstituentCustomFieldsSingleConstituentAsyncWithHttpInfo($constituent_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConstituentCustomFieldsSingleConstituentAsyncWithHttpInfo
     *
     * Constituent custom field list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the custom fields for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentCustomFieldsSingleConstituentAsyncWithHttpInfo($constituent_id)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionCustomFieldRead';
        $request = $this->listConstituentCustomFieldsSingleConstituentRequest($constituent_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listConstituentCustomFieldsSingleConstituent'
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the custom fields for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listConstituentCustomFieldsSingleConstituentRequest($constituent_id)
    {
        // verify the required parameter 'constituent_id' is set
        if ($constituent_id === null || (is_array($constituent_id) && count($constituent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $constituent_id when calling listConstituentCustomFieldsSingleConstituent'
            );
        }

        $resourcePath = '/constituents/{constituent_id}/customfields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($constituent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'constituent_id' . '}',
                ObjectSerializer::toPathValue($constituent_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listConstituentFundraiserAssignmentsSingleConstituent
     *
     * Fundraiser assignment list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the fundraiser assignments for. (required)
     * @param  bool $include_inactive Set this parameter to \&quot;false\&quot; to exclude inactive fundraiser assignments in the response. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionFundraiserAssignmentRead
     */
    public function listConstituentFundraiserAssignmentsSingleConstituent($constituent_id, $include_inactive = null)
    {
        list($response) = $this->listConstituentFundraiserAssignmentsSingleConstituentWithHttpInfo($constituent_id, $include_inactive);
        return $response;
    }

    /**
     * Operation listConstituentFundraiserAssignmentsSingleConstituentWithHttpInfo
     *
     * Fundraiser assignment list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the fundraiser assignments for. (required)
     * @param  bool $include_inactive Set this parameter to \&quot;false\&quot; to exclude inactive fundraiser assignments in the response. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionFundraiserAssignmentRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConstituentFundraiserAssignmentsSingleConstituentWithHttpInfo($constituent_id, $include_inactive = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionFundraiserAssignmentRead';
        $request = $this->listConstituentFundraiserAssignmentsSingleConstituentRequest($constituent_id, $include_inactive);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionFundraiserAssignmentRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConstituentFundraiserAssignmentsSingleConstituentAsync
     *
     * Fundraiser assignment list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the fundraiser assignments for. (required)
     * @param  bool $include_inactive Set this parameter to \&quot;false\&quot; to exclude inactive fundraiser assignments in the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentFundraiserAssignmentsSingleConstituentAsync($constituent_id, $include_inactive = null)
    {
        return $this->listConstituentFundraiserAssignmentsSingleConstituentAsyncWithHttpInfo($constituent_id, $include_inactive)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConstituentFundraiserAssignmentsSingleConstituentAsyncWithHttpInfo
     *
     * Fundraiser assignment list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the fundraiser assignments for. (required)
     * @param  bool $include_inactive Set this parameter to \&quot;false\&quot; to exclude inactive fundraiser assignments in the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentFundraiserAssignmentsSingleConstituentAsyncWithHttpInfo($constituent_id, $include_inactive = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionFundraiserAssignmentRead';
        $request = $this->listConstituentFundraiserAssignmentsSingleConstituentRequest($constituent_id, $include_inactive);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listConstituentFundraiserAssignmentsSingleConstituent'
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the fundraiser assignments for. (required)
     * @param  bool $include_inactive Set this parameter to \&quot;false\&quot; to exclude inactive fundraiser assignments in the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listConstituentFundraiserAssignmentsSingleConstituentRequest($constituent_id, $include_inactive = null)
    {
        // verify the required parameter 'constituent_id' is set
        if ($constituent_id === null || (is_array($constituent_id) && count($constituent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $constituent_id when calling listConstituentFundraiserAssignmentsSingleConstituent'
            );
        }

        $resourcePath = '/constituents/{constituent_id}/fundraiserassignments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_inactive !== null) {
            $queryParams['include_inactive'] = ObjectSerializer::toQueryValue($include_inactive, null);
        }

        // path params
        if ($constituent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'constituent_id' . '}',
                ObjectSerializer::toPathValue($constituent_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listConstituentFundraisersSingleConstituent
     *
     * Fundraiser list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the fundraisers for. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionConstituentFundraiserRead
     */
    public function listConstituentFundraisersSingleConstituent($constituent_id)
    {
        list($response) = $this->listConstituentFundraisersSingleConstituentWithHttpInfo($constituent_id);
        return $response;
    }

    /**
     * Operation listConstituentFundraisersSingleConstituentWithHttpInfo
     *
     * Fundraiser list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the fundraisers for. (required)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionConstituentFundraiserRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConstituentFundraisersSingleConstituentWithHttpInfo($constituent_id)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionConstituentFundraiserRead';
        $request = $this->listConstituentFundraisersSingleConstituentRequest($constituent_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionConstituentFundraiserRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConstituentFundraisersSingleConstituentAsync
     *
     * Fundraiser list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the fundraisers for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentFundraisersSingleConstituentAsync($constituent_id)
    {
        return $this->listConstituentFundraisersSingleConstituentAsyncWithHttpInfo($constituent_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConstituentFundraisersSingleConstituentAsyncWithHttpInfo
     *
     * Fundraiser list (Single constituent)
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the fundraisers for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentFundraisersSingleConstituentAsyncWithHttpInfo($constituent_id)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionConstituentFundraiserRead';
        $request = $this->listConstituentFundraisersSingleConstituentRequest($constituent_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listConstituentFundraisersSingleConstituent'
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to retrieve the fundraisers for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listConstituentFundraisersSingleConstituentRequest($constituent_id)
    {
        // verify the required parameter 'constituent_id' is set
        if ($constituent_id === null || (is_array($constituent_id) && count($constituent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $constituent_id when calling listConstituentFundraisersSingleConstituent'
            );
        }

        $resourcePath = '/constituents/{constituent_id}/fundraisers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($constituent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'constituent_id' . '}',
                ObjectSerializer::toPathValue($constituent_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listConstituents
     *
     * Constituent list
     *
     * @param  string $constituent_code Represents a list of constituent codes. Returns constituents if any of the specified constituent codes match any of their active constituent codes. For example, \&quot;constituent_code&#x3D;Board Member&amp;amp;constituent_code&#x3D;Volunteer\&quot; returns constituents with either \&quot;Board Member\&quot; or \&quot;Volunteer\&quot; constituent codes. (optional)
     * @param  string $constituent_id Represents a list of constituent identifiers. Returns constituents if any of the specified constituent identifiers match any of their constituents. For example, \&quot;constituent_id&#x3D;280&amp;amp;constituent_id&#x3D;1232\&quot; returns constituents with either \&quot;280\&quot; or \&quot;1232\&quot; constituent identifiers. (optional)
     * @param  string $custom_field_category Represents a list of custom field categories. Returns constituents if any of the specified custom field categories match any of their active custom fields. For example, \&quot;custom_field_category&#x3D;Interests&amp;amp;custom_field_category&#x3D;Anniversary\&quot; returns constituents with either \&quot;Interests\&quot; or \&quot;Anniversary\&quot; custom fields. (optional)
     * @param  string $fields Represents the fields to include on the returned records. For example, \&quot;fields&#x3D;id,first,last,deceased_date\&quot;. The &lt;code&gt;id&lt;/code&gt; field will always be returned. (optional)
     * @param  string $fundraiser_status Represents a comma-separated list of fundraiser statuses. Returns constituents if any of the specified fundraiser statuses match the constituent&#x27;s fundraiser status. For example, \&quot;fundraiser_status&#x3D;Active,None\&quot; returns constituents whose fundraiser status that matches Active or None.  Valid values for this filter are Active, Inactive, and None. (optional)
     * @param  bool $include_deceased Set this parameter to \&quot;true\&quot; to include deceased constituents in the response. (optional)
     * @param  bool $include_inactive Set this parameter to \&quot;true\&quot; to include inactive constituents in the response. (optional)
     * @param  string $list_id Defines a list identifier used to filter the set of constituents to those included in the specified list. If this value is set, other specified filters will be ignored. (optional)
     * @param  string $postal_code Represents a comma-separated list of postal codes. Returns constituents if any of the specified postal codes match the postal code for their preferred address. For example, \&quot;postal_code&#x3D;99577,14623\&quot; returns constituents whose preferred address has a postal code that matches or starts with 99577 or 14623, such as 99577, 14623, or 99577-0727. (optional)
     * @param  string $date_added Format - date-time (as date-time in RFC3339). Represents a filter for results created on or after the specified date. Adds the sort_token parameter to the next_link URL to ensure that constituents are stably sorted. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $last_modified Format - date-time (as date-time in RFC3339). Represents a filter for results modified on or after the specified date. Adds the sort_token parameter to the next_link URL to ensure that constituents are stably sorted. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $sort_token Represents a token filter to provide the next stable-sorted list of results and to ensure that the order persists even if changes occur while working through a paginated list. The token is provided on the next_link collection response property when the request specifies the sort_token filter. The last_modified, date_added, and sort parameters also add the token to the next_link URL, although the sort parameter only adds the token when it sorts by just the date_added field or just the date_modified field. (optional)
     * @param  string $sort Represents a list of fields to sort the results by. Returns a list that sorts constituents based on the supplied fields. Results are in ascending order by default, and a &#x27;-&#x27; sign denotes descending order. For example, \&quot;sort&#x3D;date_added,-last\&quot; sorts constituents by the \&quot;date_added\&quot; field in ascending order and then by the \&quot;last\&quot; field in descending order.  If only the date_modified field or only the date_added field is provided, then this adds the sort_token parameter to the next_link URL to ensure that constituents are stably sorted. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionConstituentListItem
     */
    public function listConstituents($constituent_code = null, $constituent_id = null, $custom_field_category = null, $fields = null, $fundraiser_status = null, $include_deceased = null, $include_inactive = null, $list_id = null, $postal_code = null, $date_added = null, $last_modified = null, $sort_token = null, $sort = null, $limit = null, $offset = null)
    {
        list($response) = $this->listConstituentsWithHttpInfo($constituent_code, $constituent_id, $custom_field_category, $fields, $fundraiser_status, $include_deceased, $include_inactive, $list_id, $postal_code, $date_added, $last_modified, $sort_token, $sort, $limit, $offset);
        return $response;
    }

    /**
     * Operation listConstituentsWithHttpInfo
     *
     * Constituent list
     *
     * @param  string $constituent_code Represents a list of constituent codes. Returns constituents if any of the specified constituent codes match any of their active constituent codes. For example, \&quot;constituent_code&#x3D;Board Member&amp;amp;constituent_code&#x3D;Volunteer\&quot; returns constituents with either \&quot;Board Member\&quot; or \&quot;Volunteer\&quot; constituent codes. (optional)
     * @param  string $constituent_id Represents a list of constituent identifiers. Returns constituents if any of the specified constituent identifiers match any of their constituents. For example, \&quot;constituent_id&#x3D;280&amp;amp;constituent_id&#x3D;1232\&quot; returns constituents with either \&quot;280\&quot; or \&quot;1232\&quot; constituent identifiers. (optional)
     * @param  string $custom_field_category Represents a list of custom field categories. Returns constituents if any of the specified custom field categories match any of their active custom fields. For example, \&quot;custom_field_category&#x3D;Interests&amp;amp;custom_field_category&#x3D;Anniversary\&quot; returns constituents with either \&quot;Interests\&quot; or \&quot;Anniversary\&quot; custom fields. (optional)
     * @param  string $fields Represents the fields to include on the returned records. For example, \&quot;fields&#x3D;id,first,last,deceased_date\&quot;. The &lt;code&gt;id&lt;/code&gt; field will always be returned. (optional)
     * @param  string $fundraiser_status Represents a comma-separated list of fundraiser statuses. Returns constituents if any of the specified fundraiser statuses match the constituent&#x27;s fundraiser status. For example, \&quot;fundraiser_status&#x3D;Active,None\&quot; returns constituents whose fundraiser status that matches Active or None.  Valid values for this filter are Active, Inactive, and None. (optional)
     * @param  bool $include_deceased Set this parameter to \&quot;true\&quot; to include deceased constituents in the response. (optional)
     * @param  bool $include_inactive Set this parameter to \&quot;true\&quot; to include inactive constituents in the response. (optional)
     * @param  string $list_id Defines a list identifier used to filter the set of constituents to those included in the specified list. If this value is set, other specified filters will be ignored. (optional)
     * @param  string $postal_code Represents a comma-separated list of postal codes. Returns constituents if any of the specified postal codes match the postal code for their preferred address. For example, \&quot;postal_code&#x3D;99577,14623\&quot; returns constituents whose preferred address has a postal code that matches or starts with 99577 or 14623, such as 99577, 14623, or 99577-0727. (optional)
     * @param  string $date_added Format - date-time (as date-time in RFC3339). Represents a filter for results created on or after the specified date. Adds the sort_token parameter to the next_link URL to ensure that constituents are stably sorted. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $last_modified Format - date-time (as date-time in RFC3339). Represents a filter for results modified on or after the specified date. Adds the sort_token parameter to the next_link URL to ensure that constituents are stably sorted. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $sort_token Represents a token filter to provide the next stable-sorted list of results and to ensure that the order persists even if changes occur while working through a paginated list. The token is provided on the next_link collection response property when the request specifies the sort_token filter. The last_modified, date_added, and sort parameters also add the token to the next_link URL, although the sort parameter only adds the token when it sorts by just the date_added field or just the date_modified field. (optional)
     * @param  string $sort Represents a list of fields to sort the results by. Returns a list that sorts constituents based on the supplied fields. Results are in ascending order by default, and a &#x27;-&#x27; sign denotes descending order. For example, \&quot;sort&#x3D;date_added,-last\&quot; sorts constituents by the \&quot;date_added\&quot; field in ascending order and then by the \&quot;last\&quot; field in descending order.  If only the date_modified field or only the date_added field is provided, then this adds the sort_token parameter to the next_link URL to ensure that constituents are stably sorted. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionConstituentListItem, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConstituentsWithHttpInfo($constituent_code = null, $constituent_id = null, $custom_field_category = null, $fields = null, $fundraiser_status = null, $include_deceased = null, $include_inactive = null, $list_id = null, $postal_code = null, $date_added = null, $last_modified = null, $sort_token = null, $sort = null, $limit = null, $offset = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionConstituentListItem';
        $request = $this->listConstituentsRequest($constituent_code, $constituent_id, $custom_field_category, $fields, $fundraiser_status, $include_deceased, $include_inactive, $list_id, $postal_code, $date_added, $last_modified, $sort_token, $sort, $limit, $offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionConstituentListItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConstituentsAsync
     *
     * Constituent list
     *
     * @param  string $constituent_code Represents a list of constituent codes. Returns constituents if any of the specified constituent codes match any of their active constituent codes. For example, \&quot;constituent_code&#x3D;Board Member&amp;amp;constituent_code&#x3D;Volunteer\&quot; returns constituents with either \&quot;Board Member\&quot; or \&quot;Volunteer\&quot; constituent codes. (optional)
     * @param  string $constituent_id Represents a list of constituent identifiers. Returns constituents if any of the specified constituent identifiers match any of their constituents. For example, \&quot;constituent_id&#x3D;280&amp;amp;constituent_id&#x3D;1232\&quot; returns constituents with either \&quot;280\&quot; or \&quot;1232\&quot; constituent identifiers. (optional)
     * @param  string $custom_field_category Represents a list of custom field categories. Returns constituents if any of the specified custom field categories match any of their active custom fields. For example, \&quot;custom_field_category&#x3D;Interests&amp;amp;custom_field_category&#x3D;Anniversary\&quot; returns constituents with either \&quot;Interests\&quot; or \&quot;Anniversary\&quot; custom fields. (optional)
     * @param  string $fields Represents the fields to include on the returned records. For example, \&quot;fields&#x3D;id,first,last,deceased_date\&quot;. The &lt;code&gt;id&lt;/code&gt; field will always be returned. (optional)
     * @param  string $fundraiser_status Represents a comma-separated list of fundraiser statuses. Returns constituents if any of the specified fundraiser statuses match the constituent&#x27;s fundraiser status. For example, \&quot;fundraiser_status&#x3D;Active,None\&quot; returns constituents whose fundraiser status that matches Active or None.  Valid values for this filter are Active, Inactive, and None. (optional)
     * @param  bool $include_deceased Set this parameter to \&quot;true\&quot; to include deceased constituents in the response. (optional)
     * @param  bool $include_inactive Set this parameter to \&quot;true\&quot; to include inactive constituents in the response. (optional)
     * @param  string $list_id Defines a list identifier used to filter the set of constituents to those included in the specified list. If this value is set, other specified filters will be ignored. (optional)
     * @param  string $postal_code Represents a comma-separated list of postal codes. Returns constituents if any of the specified postal codes match the postal code for their preferred address. For example, \&quot;postal_code&#x3D;99577,14623\&quot; returns constituents whose preferred address has a postal code that matches or starts with 99577 or 14623, such as 99577, 14623, or 99577-0727. (optional)
     * @param  string $date_added Format - date-time (as date-time in RFC3339). Represents a filter for results created on or after the specified date. Adds the sort_token parameter to the next_link URL to ensure that constituents are stably sorted. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $last_modified Format - date-time (as date-time in RFC3339). Represents a filter for results modified on or after the specified date. Adds the sort_token parameter to the next_link URL to ensure that constituents are stably sorted. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $sort_token Represents a token filter to provide the next stable-sorted list of results and to ensure that the order persists even if changes occur while working through a paginated list. The token is provided on the next_link collection response property when the request specifies the sort_token filter. The last_modified, date_added, and sort parameters also add the token to the next_link URL, although the sort parameter only adds the token when it sorts by just the date_added field or just the date_modified field. (optional)
     * @param  string $sort Represents a list of fields to sort the results by. Returns a list that sorts constituents based on the supplied fields. Results are in ascending order by default, and a &#x27;-&#x27; sign denotes descending order. For example, \&quot;sort&#x3D;date_added,-last\&quot; sorts constituents by the \&quot;date_added\&quot; field in ascending order and then by the \&quot;last\&quot; field in descending order.  If only the date_modified field or only the date_added field is provided, then this adds the sort_token parameter to the next_link URL to ensure that constituents are stably sorted. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentsAsync($constituent_code = null, $constituent_id = null, $custom_field_category = null, $fields = null, $fundraiser_status = null, $include_deceased = null, $include_inactive = null, $list_id = null, $postal_code = null, $date_added = null, $last_modified = null, $sort_token = null, $sort = null, $limit = null, $offset = null)
    {
        return $this->listConstituentsAsyncWithHttpInfo($constituent_code, $constituent_id, $custom_field_category, $fields, $fundraiser_status, $include_deceased, $include_inactive, $list_id, $postal_code, $date_added, $last_modified, $sort_token, $sort, $limit, $offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConstituentsAsyncWithHttpInfo
     *
     * Constituent list
     *
     * @param  string $constituent_code Represents a list of constituent codes. Returns constituents if any of the specified constituent codes match any of their active constituent codes. For example, \&quot;constituent_code&#x3D;Board Member&amp;amp;constituent_code&#x3D;Volunteer\&quot; returns constituents with either \&quot;Board Member\&quot; or \&quot;Volunteer\&quot; constituent codes. (optional)
     * @param  string $constituent_id Represents a list of constituent identifiers. Returns constituents if any of the specified constituent identifiers match any of their constituents. For example, \&quot;constituent_id&#x3D;280&amp;amp;constituent_id&#x3D;1232\&quot; returns constituents with either \&quot;280\&quot; or \&quot;1232\&quot; constituent identifiers. (optional)
     * @param  string $custom_field_category Represents a list of custom field categories. Returns constituents if any of the specified custom field categories match any of their active custom fields. For example, \&quot;custom_field_category&#x3D;Interests&amp;amp;custom_field_category&#x3D;Anniversary\&quot; returns constituents with either \&quot;Interests\&quot; or \&quot;Anniversary\&quot; custom fields. (optional)
     * @param  string $fields Represents the fields to include on the returned records. For example, \&quot;fields&#x3D;id,first,last,deceased_date\&quot;. The &lt;code&gt;id&lt;/code&gt; field will always be returned. (optional)
     * @param  string $fundraiser_status Represents a comma-separated list of fundraiser statuses. Returns constituents if any of the specified fundraiser statuses match the constituent&#x27;s fundraiser status. For example, \&quot;fundraiser_status&#x3D;Active,None\&quot; returns constituents whose fundraiser status that matches Active or None.  Valid values for this filter are Active, Inactive, and None. (optional)
     * @param  bool $include_deceased Set this parameter to \&quot;true\&quot; to include deceased constituents in the response. (optional)
     * @param  bool $include_inactive Set this parameter to \&quot;true\&quot; to include inactive constituents in the response. (optional)
     * @param  string $list_id Defines a list identifier used to filter the set of constituents to those included in the specified list. If this value is set, other specified filters will be ignored. (optional)
     * @param  string $postal_code Represents a comma-separated list of postal codes. Returns constituents if any of the specified postal codes match the postal code for their preferred address. For example, \&quot;postal_code&#x3D;99577,14623\&quot; returns constituents whose preferred address has a postal code that matches or starts with 99577 or 14623, such as 99577, 14623, or 99577-0727. (optional)
     * @param  string $date_added Format - date-time (as date-time in RFC3339). Represents a filter for results created on or after the specified date. Adds the sort_token parameter to the next_link URL to ensure that constituents are stably sorted. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $last_modified Format - date-time (as date-time in RFC3339). Represents a filter for results modified on or after the specified date. Adds the sort_token parameter to the next_link URL to ensure that constituents are stably sorted. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $sort_token Represents a token filter to provide the next stable-sorted list of results and to ensure that the order persists even if changes occur while working through a paginated list. The token is provided on the next_link collection response property when the request specifies the sort_token filter. The last_modified, date_added, and sort parameters also add the token to the next_link URL, although the sort parameter only adds the token when it sorts by just the date_added field or just the date_modified field. (optional)
     * @param  string $sort Represents a list of fields to sort the results by. Returns a list that sorts constituents based on the supplied fields. Results are in ascending order by default, and a &#x27;-&#x27; sign denotes descending order. For example, \&quot;sort&#x3D;date_added,-last\&quot; sorts constituents by the \&quot;date_added\&quot; field in ascending order and then by the \&quot;last\&quot; field in descending order.  If only the date_modified field or only the date_added field is provided, then this adds the sort_token parameter to the next_link URL to ensure that constituents are stably sorted. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConstituentsAsyncWithHttpInfo($constituent_code = null, $constituent_id = null, $custom_field_category = null, $fields = null, $fundraiser_status = null, $include_deceased = null, $include_inactive = null, $list_id = null, $postal_code = null, $date_added = null, $last_modified = null, $sort_token = null, $sort = null, $limit = null, $offset = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionConstituentListItem';
        $request = $this->listConstituentsRequest($constituent_code, $constituent_id, $custom_field_category, $fields, $fundraiser_status, $include_deceased, $include_inactive, $list_id, $postal_code, $date_added, $last_modified, $sort_token, $sort, $limit, $offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listConstituents'
     *
     * @param  string $constituent_code Represents a list of constituent codes. Returns constituents if any of the specified constituent codes match any of their active constituent codes. For example, \&quot;constituent_code&#x3D;Board Member&amp;amp;constituent_code&#x3D;Volunteer\&quot; returns constituents with either \&quot;Board Member\&quot; or \&quot;Volunteer\&quot; constituent codes. (optional)
     * @param  string $constituent_id Represents a list of constituent identifiers. Returns constituents if any of the specified constituent identifiers match any of their constituents. For example, \&quot;constituent_id&#x3D;280&amp;amp;constituent_id&#x3D;1232\&quot; returns constituents with either \&quot;280\&quot; or \&quot;1232\&quot; constituent identifiers. (optional)
     * @param  string $custom_field_category Represents a list of custom field categories. Returns constituents if any of the specified custom field categories match any of their active custom fields. For example, \&quot;custom_field_category&#x3D;Interests&amp;amp;custom_field_category&#x3D;Anniversary\&quot; returns constituents with either \&quot;Interests\&quot; or \&quot;Anniversary\&quot; custom fields. (optional)
     * @param  string $fields Represents the fields to include on the returned records. For example, \&quot;fields&#x3D;id,first,last,deceased_date\&quot;. The &lt;code&gt;id&lt;/code&gt; field will always be returned. (optional)
     * @param  string $fundraiser_status Represents a comma-separated list of fundraiser statuses. Returns constituents if any of the specified fundraiser statuses match the constituent&#x27;s fundraiser status. For example, \&quot;fundraiser_status&#x3D;Active,None\&quot; returns constituents whose fundraiser status that matches Active or None.  Valid values for this filter are Active, Inactive, and None. (optional)
     * @param  bool $include_deceased Set this parameter to \&quot;true\&quot; to include deceased constituents in the response. (optional)
     * @param  bool $include_inactive Set this parameter to \&quot;true\&quot; to include inactive constituents in the response. (optional)
     * @param  string $list_id Defines a list identifier used to filter the set of constituents to those included in the specified list. If this value is set, other specified filters will be ignored. (optional)
     * @param  string $postal_code Represents a comma-separated list of postal codes. Returns constituents if any of the specified postal codes match the postal code for their preferred address. For example, \&quot;postal_code&#x3D;99577,14623\&quot; returns constituents whose preferred address has a postal code that matches or starts with 99577 or 14623, such as 99577, 14623, or 99577-0727. (optional)
     * @param  string $date_added Format - date-time (as date-time in RFC3339). Represents a filter for results created on or after the specified date. Adds the sort_token parameter to the next_link URL to ensure that constituents are stably sorted. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $last_modified Format - date-time (as date-time in RFC3339). Represents a filter for results modified on or after the specified date. Adds the sort_token parameter to the next_link URL to ensure that constituents are stably sorted. The filter respects time offsets from UTC per the ISO-8601 format: 2016-05-05T17:59:31.1600745-04:00. (optional)
     * @param  string $sort_token Represents a token filter to provide the next stable-sorted list of results and to ensure that the order persists even if changes occur while working through a paginated list. The token is provided on the next_link collection response property when the request specifies the sort_token filter. The last_modified, date_added, and sort parameters also add the token to the next_link URL, although the sort parameter only adds the token when it sorts by just the date_added field or just the date_modified field. (optional)
     * @param  string $sort Represents a list of fields to sort the results by. Returns a list that sorts constituents based on the supplied fields. Results are in ascending order by default, and a &#x27;-&#x27; sign denotes descending order. For example, \&quot;sort&#x3D;date_added,-last\&quot; sorts constituents by the \&quot;date_added\&quot; field in ascending order and then by the \&quot;last\&quot; field in descending order.  If only the date_modified field or only the date_added field is provided, then this adds the sort_token parameter to the next_link URL to ensure that constituents are stably sorted. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listConstituentsRequest($constituent_code = null, $constituent_id = null, $custom_field_category = null, $fields = null, $fundraiser_status = null, $include_deceased = null, $include_inactive = null, $list_id = null, $postal_code = null, $date_added = null, $last_modified = null, $sort_token = null, $sort = null, $limit = null, $offset = null)
    {

        $resourcePath = '/constituents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($constituent_code !== null) {
            $queryParams['constituent_code'] = ObjectSerializer::toQueryValue($constituent_code, null);
        }
        // query params
        if ($constituent_id !== null) {
            $queryParams['constituent_id'] = ObjectSerializer::toQueryValue($constituent_id, null);
        }
        // query params
        if ($custom_field_category !== null) {
            $queryParams['custom_field_category'] = ObjectSerializer::toQueryValue($custom_field_category, null);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields, null);
        }
        // query params
        if ($fundraiser_status !== null) {
            $queryParams['fundraiser_status'] = ObjectSerializer::toQueryValue($fundraiser_status, null);
        }
        // query params
        if ($include_deceased !== null) {
            $queryParams['include_deceased'] = ObjectSerializer::toQueryValue($include_deceased, null);
        }
        // query params
        if ($include_inactive !== null) {
            $queryParams['include_inactive'] = ObjectSerializer::toQueryValue($include_inactive, null);
        }
        // query params
        if ($list_id !== null) {
            $queryParams['list_id'] = ObjectSerializer::toQueryValue($list_id, null);
        }
        // query params
        if ($postal_code !== null) {
            $queryParams['postal_code'] = ObjectSerializer::toQueryValue($postal_code, null);
        }
        // query params
        if ($date_added !== null) {
            $queryParams['date_added'] = ObjectSerializer::toQueryValue($date_added, null);
        }
        // query params
        if ($last_modified !== null) {
            $queryParams['last_modified'] = ObjectSerializer::toQueryValue($last_modified, null);
        }
        // query params
        if ($sort_token !== null) {
            $queryParams['sort_token'] = ObjectSerializer::toQueryValue($sort_token, null);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort, null);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listGenders
     *
     * Genders
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString
     */
    public function listGenders()
    {
        list($response) = $this->listGendersWithHttpInfo();
        return $response;
    }

    /**
     * Operation listGendersWithHttpInfo
     *
     * Genders
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString, HTTP status code, HTTP response headers (array of strings)
     */
    public function listGendersWithHttpInfo()
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString';
        $request = $this->listGendersRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listGendersAsync
     *
     * Genders
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listGendersAsync()
    {
        return $this->listGendersAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listGendersAsyncWithHttpInfo
     *
     * Genders
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listGendersAsyncWithHttpInfo()
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString';
        $request = $this->listGendersRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listGenders'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listGendersRequest()
    {

        $resourcePath = '/genders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMaritalStatuses
     *
     * Marital statuses
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString
     */
    public function listMaritalStatuses()
    {
        list($response) = $this->listMaritalStatusesWithHttpInfo();
        return $response;
    }

    /**
     * Operation listMaritalStatusesWithHttpInfo
     *
     * Marital statuses
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString, HTTP status code, HTTP response headers (array of strings)
     */
    public function listMaritalStatusesWithHttpInfo()
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString';
        $request = $this->listMaritalStatusesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listMaritalStatusesAsync
     *
     * Marital statuses
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMaritalStatusesAsync()
    {
        return $this->listMaritalStatusesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMaritalStatusesAsyncWithHttpInfo
     *
     * Marital statuses
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMaritalStatusesAsyncWithHttpInfo()
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString';
        $request = $this->listMaritalStatusesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listMaritalStatuses'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listMaritalStatusesRequest()
    {

        $resourcePath = '/maritalstatuses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listSuffixes
     *
     * Suffixes
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString
     */
    public function listSuffixes()
    {
        list($response) = $this->listSuffixesWithHttpInfo();
        return $response;
    }

    /**
     * Operation listSuffixesWithHttpInfo
     *
     * Suffixes
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString, HTTP status code, HTTP response headers (array of strings)
     */
    public function listSuffixesWithHttpInfo()
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString';
        $request = $this->listSuffixesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listSuffixesAsync
     *
     * Suffixes
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listSuffixesAsync()
    {
        return $this->listSuffixesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listSuffixesAsyncWithHttpInfo
     *
     * Suffixes
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listSuffixesAsyncWithHttpInfo()
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString';
        $request = $this->listSuffixesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listSuffixes'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listSuffixesRequest()
    {

        $resourcePath = '/suffixes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listTitles
     *
     * Titles
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString
     */
    public function listTitles()
    {
        list($response) = $this->listTitlesWithHttpInfo();
        return $response;
    }

    /**
     * Operation listTitlesWithHttpInfo
     *
     * Titles
     *
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString, HTTP status code, HTTP response headers (array of strings)
     */
    public function listTitlesWithHttpInfo()
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString';
        $request = $this->listTitlesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listTitlesAsync
     *
     * Titles
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTitlesAsync()
    {
        return $this->listTitlesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listTitlesAsyncWithHttpInfo
     *
     * Titles
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTitlesAsyncWithHttpInfo()
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionString';
        $request = $this->listTitlesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listTitles'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listTitlesRequest()
    {

        $resourcePath = '/titles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchConstituentProfilePicture
     *
     * Profile picture
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to update for the current profile picture. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ProfilePictureEdit $body An object that represents the properties for the constituent picture to update. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function patchConstituentProfilePicture($constituent_id, $body = null)
    {
        $this->patchConstituentProfilePictureWithHttpInfo($constituent_id, $body);
    }

    /**
     * Operation patchConstituentProfilePictureWithHttpInfo
     *
     * Profile picture
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to update for the current profile picture. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ProfilePictureEdit $body An object that represents the properties for the constituent picture to update. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchConstituentProfilePictureWithHttpInfo($constituent_id, $body = null)
    {
        $returnType = '';
        $request = $this->patchConstituentProfilePictureRequest($constituent_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation patchConstituentProfilePictureAsync
     *
     * Profile picture
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to update for the current profile picture. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ProfilePictureEdit $body An object that represents the properties for the constituent picture to update. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchConstituentProfilePictureAsync($constituent_id, $body = null)
    {
        return $this->patchConstituentProfilePictureAsyncWithHttpInfo($constituent_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchConstituentProfilePictureAsyncWithHttpInfo
     *
     * Profile picture
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to update for the current profile picture. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ProfilePictureEdit $body An object that represents the properties for the constituent picture to update. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchConstituentProfilePictureAsyncWithHttpInfo($constituent_id, $body = null)
    {
        $returnType = '';
        $request = $this->patchConstituentProfilePictureRequest($constituent_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchConstituentProfilePicture'
     *
     * @param  string $constituent_id The immutable system record ID of the constituent to update for the current profile picture. (required)
     * @param  \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ProfilePictureEdit $body An object that represents the properties for the constituent picture to update. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchConstituentProfilePictureRequest($constituent_id, $body = null)
    {
        // verify the required parameter 'constituent_id' is set
        if ($constituent_id === null || (is_array($constituent_id) && count($constituent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $constituent_id when calling patchConstituentProfilePicture'
            );
        }

        $resourcePath = '/constituents/{constituent_id}/profilepicture';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($constituent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'constituent_id' . '}',
                ObjectSerializer::toPathValue($constituent_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchConstituent
     *
     * Constituent (Search)
     *
     * @param  string $search_text The text to search for. If the search_text is a lookup_id, set the search_field to \&quot;lookup_id\&quot;. (required)
     * @param  string $fundraiser_status Represents a comma-separated list of fundraiser statuses. Returns constituents if any of the specified fundraiser statuses match the constituent&#x27;s fundraiser status. For example, \&quot;fundraiser_status&#x3D;Active,None\&quot; returns constituents whose fundraiser status that matches Active or None.  Valid values for this filter are Active, Inactive, and None. (optional)
     * @param  bool $include_inactive Set this parameter to \&quot;true\&quot; to include inactive constituents in the response. (optional)
     * @param  string $search_field Represents a field to search on. Currently, it only supports lookup_id. If it is provided with search_text, a constituent with lookup_id that matches the search_text will be returned. (optional)
     * @param  bool $strict_search Set this parameter to \&quot;true\&quot; to exclude constituents whose names sound like the search text but are spelled differently. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionSearchResultRead
     */
    public function searchConstituent($search_text, $fundraiser_status = null, $include_inactive = null, $search_field = null, $strict_search = null, $limit = null, $offset = null)
    {
        list($response) = $this->searchConstituentWithHttpInfo($search_text, $fundraiser_status, $include_inactive, $search_field, $strict_search, $limit, $offset);
        return $response;
    }

    /**
     * Operation searchConstituentWithHttpInfo
     *
     * Constituent (Search)
     *
     * @param  string $search_text The text to search for. If the search_text is a lookup_id, set the search_field to \&quot;lookup_id\&quot;. (required)
     * @param  string $fundraiser_status Represents a comma-separated list of fundraiser statuses. Returns constituents if any of the specified fundraiser statuses match the constituent&#x27;s fundraiser status. For example, \&quot;fundraiser_status&#x3D;Active,None\&quot; returns constituents whose fundraiser status that matches Active or None.  Valid values for this filter are Active, Inactive, and None. (optional)
     * @param  bool $include_inactive Set this parameter to \&quot;true\&quot; to include inactive constituents in the response. (optional)
     * @param  string $search_field Represents a field to search on. Currently, it only supports lookup_id. If it is provided with search_text, a constituent with lookup_id that matches the search_text will be returned. (optional)
     * @param  bool $strict_search Set this parameter to \&quot;true\&quot; to exclude constituents whose names sound like the search text but are spelled differently. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \BurgerDigital\BlackbaudPhpSdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionSearchResultRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchConstituentWithHttpInfo($search_text, $fundraiser_status = null, $include_inactive = null, $search_field = null, $strict_search = null, $limit = null, $offset = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionSearchResultRead';
        $request = $this->searchConstituentRequest($search_text, $fundraiser_status, $include_inactive, $search_field, $strict_search, $limit, $offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionSearchResultRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchConstituentAsync
     *
     * Constituent (Search)
     *
     * @param  string $search_text The text to search for. If the search_text is a lookup_id, set the search_field to \&quot;lookup_id\&quot;. (required)
     * @param  string $fundraiser_status Represents a comma-separated list of fundraiser statuses. Returns constituents if any of the specified fundraiser statuses match the constituent&#x27;s fundraiser status. For example, \&quot;fundraiser_status&#x3D;Active,None\&quot; returns constituents whose fundraiser status that matches Active or None.  Valid values for this filter are Active, Inactive, and None. (optional)
     * @param  bool $include_inactive Set this parameter to \&quot;true\&quot; to include inactive constituents in the response. (optional)
     * @param  string $search_field Represents a field to search on. Currently, it only supports lookup_id. If it is provided with search_text, a constituent with lookup_id that matches the search_text will be returned. (optional)
     * @param  bool $strict_search Set this parameter to \&quot;true\&quot; to exclude constituents whose names sound like the search text but are spelled differently. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchConstituentAsync($search_text, $fundraiser_status = null, $include_inactive = null, $search_field = null, $strict_search = null, $limit = null, $offset = null)
    {
        return $this->searchConstituentAsyncWithHttpInfo($search_text, $fundraiser_status, $include_inactive, $search_field, $strict_search, $limit, $offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchConstituentAsyncWithHttpInfo
     *
     * Constituent (Search)
     *
     * @param  string $search_text The text to search for. If the search_text is a lookup_id, set the search_field to \&quot;lookup_id\&quot;. (required)
     * @param  string $fundraiser_status Represents a comma-separated list of fundraiser statuses. Returns constituents if any of the specified fundraiser statuses match the constituent&#x27;s fundraiser status. For example, \&quot;fundraiser_status&#x3D;Active,None\&quot; returns constituents whose fundraiser status that matches Active or None.  Valid values for this filter are Active, Inactive, and None. (optional)
     * @param  bool $include_inactive Set this parameter to \&quot;true\&quot; to include inactive constituents in the response. (optional)
     * @param  string $search_field Represents a field to search on. Currently, it only supports lookup_id. If it is provided with search_text, a constituent with lookup_id that matches the search_text will be returned. (optional)
     * @param  bool $strict_search Set this parameter to \&quot;true\&quot; to exclude constituents whose names sound like the search text but are spelled differently. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchConstituentAsyncWithHttpInfo($search_text, $fundraiser_status = null, $include_inactive = null, $search_field = null, $strict_search = null, $limit = null, $offset = null)
    {
        $returnType = '\BurgerDigital\BlackbaudPhpSdk\BurgerDigital\BlackbaudPhpSdk\Models\ApiCollectionSearchResultRead';
        $request = $this->searchConstituentRequest($search_text, $fundraiser_status, $include_inactive, $search_field, $strict_search, $limit, $offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchConstituent'
     *
     * @param  string $search_text The text to search for. If the search_text is a lookup_id, set the search_field to \&quot;lookup_id\&quot;. (required)
     * @param  string $fundraiser_status Represents a comma-separated list of fundraiser statuses. Returns constituents if any of the specified fundraiser statuses match the constituent&#x27;s fundraiser status. For example, \&quot;fundraiser_status&#x3D;Active,None\&quot; returns constituents whose fundraiser status that matches Active or None.  Valid values for this filter are Active, Inactive, and None. (optional)
     * @param  bool $include_inactive Set this parameter to \&quot;true\&quot; to include inactive constituents in the response. (optional)
     * @param  string $search_field Represents a field to search on. Currently, it only supports lookup_id. If it is provided with search_text, a constituent with lookup_id that matches the search_text will be returned. (optional)
     * @param  bool $strict_search Set this parameter to \&quot;true\&quot; to exclude constituents whose names sound like the search text but are spelled differently. (optional)
     * @param  int $limit Format - int32. Represents the number of records to return. The default is 500. The maximum is 5000. (optional)
     * @param  int $offset Format - int32. Represents the number of records to skip. For use with pagination. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchConstituentRequest($search_text, $fundraiser_status = null, $include_inactive = null, $search_field = null, $strict_search = null, $limit = null, $offset = null)
    {
        // verify the required parameter 'search_text' is set
        if ($search_text === null || (is_array($search_text) && count($search_text) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $search_text when calling searchConstituent'
            );
        }

        $resourcePath = '/constituents/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($search_text !== null) {
            $queryParams['search_text'] = ObjectSerializer::toQueryValue($search_text, null);
        }
        // query params
        if ($fundraiser_status !== null) {
            $queryParams['fundraiser_status'] = ObjectSerializer::toQueryValue($fundraiser_status, null);
        }
        // query params
        if ($include_inactive !== null) {
            $queryParams['include_inactive'] = ObjectSerializer::toQueryValue($include_inactive, null);
        }
        // query params
        if ($search_field !== null) {
            $queryParams['search_field'] = ObjectSerializer::toQueryValue($search_field, null);
        }
        // query params
        if ($strict_search !== null) {
            $queryParams['strict_search'] = ObjectSerializer::toQueryValue($strict_search, null);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
